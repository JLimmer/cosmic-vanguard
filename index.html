<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- PWA & Mobile Settings -->
    <title>Cosmic Vanguard: Stellar Defense</title>
    <meta name="description" content="A retro-style space shooter game. Defeat alien fleets and upgrade your ship.">
    <meta name="theme-color" content="#000000">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="./manifest.json">
    
    <!-- Favicon (Browser Tab) -->
    <link rel="icon" type="image/png" href="./icon.png">
    
    <!-- Apple Touch Icon (iOS Home Screen) - MUST be PNG -->
    <link rel="apple-touch-icon" href="./icon.png">

    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden; /* Prevent scrolling */
            touch-action: none; /* Prevent default touch gestures */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            pointer-events: auto;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }

        .hud-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #00d4ff; /* Sci-fi blue */
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
            text-shadow: 0 0 5px #00d4ff;
            width: 100%;
        }

        /* HUD Buttons */
        .hud-btn {
            background: rgba(0, 20, 40, 0.6);
            border: 1px solid #00d4ff;
            color: #00d4ff;
            padding: 6px 12px;
            border-radius: 15px 0 15px 0; /* Sci-fi angle */
            cursor: pointer;
            font-size: 12px;
            pointer-events: auto;
            text-transform: uppercase;
            font-weight: bold;
            transition: all 0.2s;
        }
        
        .hud-btn:active {
            background: #00d4ff;
            color: #000;
        }
        
        .status-container {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 4px;
            pointer-events: none;
            margin-top: 5px;
        }

        .status-bar {
            height: 4px;
            width: 80px;
            background: rgba(0,0,0,0.5);
            border: 1px solid #555;
            display: none; /* Hidden by default */
            position: relative;
            overflow: hidden; 
        }

        .status-fill {
            height: 100%;
            width: 100%;
            transition: width 0.1s linear;
        }

        .status-label {
            font-size: 9px;
            color: #fff;
            position: absolute;
            top: -10px;
            left: 0;
            opacity: 0.8;
        }
        
        /* Action Buttons Container (Bottom) */
        #action-container {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            pointer-events: none; /* Let touches pass through gaps */
        }

        /* Ultimate Button */
        #ultimate-container {
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 20;
        }

        #ultimate-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(30, 30, 30, 0.6);
            border: 2px solid #555;
            color: #888;
            font-weight: bold;
            font-size: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            box-shadow: 0 0 10px #000;
            backdrop-filter: blur(4px);
            cursor: not-allowed;
            transition: all 0.3s;
            text-shadow: none;
            user-select: none;
        }

        #ultimate-btn.ready {
            background: radial-gradient(circle, rgba(255, 51, 0, 0.8), rgba(153, 0, 0, 0.8));
            border-color: #ff9900;
            color: #fff;
            box-shadow: 0 0 20px #ff3300;
            cursor: pointer;
            animation: pulse 1.5s infinite;
        }
        
        #ultimate-label {
            margin-top: 4px;
            color: #888;
            font-size: 10px;
            text-transform: uppercase;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
            background: rgba(0,0,0,0.5);
            padding: 2px 4px;
            border-radius: 4px;
        }
        
        /* Upgrade Button */
        #upgrade-container {
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 20;
        }

        #upgrade-btn-bottom {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(68, 51, 0, 0.6);
            border: 2px solid #ffcc00;
            color: #ffcc00;
            font-weight: bold;
            font-size: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            box-shadow: 0 0 10px #ffcc00;
            backdrop-filter: blur(4px);
            cursor: pointer;
            transition: all 0.2s;
            text-shadow: none;
            user-select: none;
        }
        
        #upgrade-btn-bottom:active {
            transform: scale(0.95);
            background: #ffcc00;
            color: #000;
        }

        #upgrade-label {
            margin-top: 4px;
            color: #ffcc00;
            font-size: 10px;
            text-transform: uppercase;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
            background: rgba(0,0,0,0.5);
            padding: 2px 4px;
            border-radius: 4px;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 15px #ff3300; }
            50% { transform: scale(1.1); box-shadow: 0 0 30px #ff3300; }
            100% { transform: scale(1); box-shadow: 0 0 15px #ff3300; }
        }
        
        /* Boss HUD */
        #boss-hud {
            position: absolute;
            top: 100px; 
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            min-width: 150px; 
            display: none; 
            flex-direction: column;
            align-items: center;
            z-index: 5;
            opacity: 0.9;
        }
        
        #boss-name {
            color: #ff3300;
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
            text-shadow: 0 0 5px #ff0000;
            margin-bottom: 3px;
            letter-spacing: 1px;
            background-color: rgba(0,0,0,0.7);
            padding: 2px 8px;
            border: 1px solid #ff3300;
            border-radius: 10px;
            white-space: nowrap;
        }
        
        #boss-health-bar {
            width: 100%;
            height: 6px;
            background: #330000;
            border: 1px solid #ff3300; 
            border-radius: 3px;
            overflow: hidden;
            box-shadow: 0 0 5px #ff0000;
        }
        
        #boss-health-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff3300, #ff9900);
            transition: width 0.2s;
        }
        
        /* Comms Panel (Gemini) */
        #comms-panel {
            position: absolute;
            top: 140px;
            width: 80%;
            max-width: 400px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 20, 40, 0.9);
            border: 1px solid #00d4ff;
            border-left: 5px solid #00d4ff;
            border-radius: 5px;
            padding: 10px;
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 4;
            transition: opacity 0.5s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        #comms-title {
            color: #ff9900;
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 5px;
            animation: blink 1s infinite;
            width: 100%;
            border-bottom: 1px solid rgba(255, 153, 0, 0.3);
            padding-bottom: 3px;
        }
        #comms-text {
            color: #fff;
            font-style: italic;
            text-align: center;
            font-size: 14px;
            line-height: 1.4;
            text-shadow: 0 0 2px #00d4ff;
        }
        
        @keyframes blink { 50% { opacity: 0.5; } }
        
        /* Pause, Instructions, Upgrade & Database Overlays */
        #pause-screen, #upgrade-screen, #instructions-screen, #database-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 30;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }
        
        #pause-text, #upgrade-title, #instructions-title, #database-title {
            color: #00d4ff;
            font-size: 30px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 5px;
            text-shadow: 0 0 10px #00d4ff;
            margin-bottom: 20px;
            text-align: center;
        }
        
        /* Instructions Content */
        .instructions-content {
            color: #ccc;
            width: 80%;
            max-width: 500px;
            text-align: left;
            font-size: 16px;
            line-height: 1.6;
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid #00d4ff;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .instructions-content strong {
            color: #ffcc00;
        }
        
        .instructions-content ul {
            padding-left: 20px;
            margin: 0;
        }
        
        .instructions-content li {
            margin-bottom: 10px;
        }
        
        /* Upgrade Grid */
        .upgrade-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            width: 90%;
            max-width: 500px;
            margin-bottom: 20px;
        }
        
        .upgrade-card {
            background: linear-gradient(135deg, rgba(0, 50, 100, 0.5), rgba(0, 20, 40, 0.8));
            border: 1px solid #00d4ff;
            border-radius: 10px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            transition: transform 0.2s;
        }
        
        .upgrade-card:hover {
            border-color: #fff;
            transform: translateY(-2px);
        }
        
        .upgrade-name { color: #fff; font-weight: bold; margin-bottom: 5px; font-size: 14px; }
        .upgrade-cost { color: #ffcc00; font-size: 14px; margin-bottom: 10px; }
        .upgrade-buy-btn {
            background: #cc3333;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            width: 100%;
        }
        .upgrade-buy-btn:disabled {
            background: #555;
            color: #888;
            cursor: not-allowed;
        }
        
        #current-latinum {
            color: #ffcc00;
            font-size: 24px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff9900;
        }
        
        /* Database Grid */
        .database-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            width: 90%;
            max-width: 700px;
            max-height: 60vh;
            overflow-y: auto;
            padding: 10px;
            margin-bottom: 20px;
        }
        
        .enemy-card {
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid #555;
            border-radius: 5px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        
        .enemy-card canvas {
            margin-bottom: 10px;
            background: rgba(0,0,0,0.5);
            border-radius: 5px;
        }
        
        .enemy-name { color: #ff9900; font-weight: bold; font-size: 14px; margin-bottom: 3px; text-transform: uppercase; }
        .enemy-desc { color: #ccc; font-size: 11px; margin-bottom: 5px; font-style: italic; line-height: 1.2; }
        .enemy-stats { color: #00d4ff; font-size: 10px; }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(20,20,30,0.9), rgba(0,0,0,1));
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 10;
        }

        h1 {
            color: #ff9900; /* Sci-fi orange */
            font-size: 40px;
            margin-bottom: 10px;
            text-align: center;
            text-shadow: 0 0 20px #ff9900;
            letter-spacing: 2px;
        }

        p {
            color: #ccc;
            text-align: center;
            max-width: 80%;
            line-height: 1.5;
        }

        .btn {
            margin-top: 15px;
            padding: 15px 40px;
            background: #cc3333; /* Sci-fi red */
            color: white;
            border: none;
            border-radius: 25px; 
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 15px #cc3333;
            transition: transform 0.1s, box-shadow 0.2s;
        }

        .btn:active {
            transform: scale(0.95);
        }
        
        .btn:hover {
            box-shadow: 0 0 25px #ff3333;
        }
        
        .btn-secondary {
            background: #0066cc;
            box-shadow: 0 0 15px #0066cc;
            font-size: 18px;
            padding: 10px 30px;
        }
        
        .btn-secondary:hover {
            box-shadow: 0 0 25px #0099ff;
        }
        
        .btn-tertiary {
            background: #444;
            box-shadow: 0 0 10px #444;
            font-size: 16px;
            padding: 10px 25px;
        }
        
        .btn-tertiary:hover {
            background: #666;
            box-shadow: 0 0 15px #666;
        }

        .hidden {
            display: none !important;
        }

        /* Continue Screen Styles */
        #continue-timer {
            font-size: 60px;
            color: #00d4ff;
            font-weight: bold;
            text-shadow: 0 0 20px #00d4ff;
            margin: 10px 0;
            animation: pulse-timer 1s infinite;
        }

        @keyframes pulse-timer {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* LCARS decorative bars */
        .lcars-bar {
            height: 10px;
            background: linear-gradient(90deg, #ff9900 20%, #cc3333 50%, #99ccff 80%);
            width: 100%;
            position: absolute;
            bottom: 0;
            opacity: 0.8;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="hud-row">
                <button id="pause-btn" class="hud-btn">PAUSE</button>
                <div id="score-display">0</div>
                <button id="mute-btn" class="hud-btn">SND: ON</button>
            </div>
            <div class="hud-row" style="justify-content: center; margin-top: -5px;">
                 <div id="highscore-display" style="color: #888; font-size: 12px;">High: 0</div>
            </div>
            <div class="hud-row" style="justify-content: space-between; margin-top: 5px; padding: 0 5px;">
                <div id="latinum-display" style="color: #ffcc00; font-weight: bold;">Credits: 0</div>
                <div id="health-display">Shields: 100%</div>
            </div>
            
            <div class="status-container">
                <div id="status-wingman" class="status-bar">
                    <span class="status-label">Fighter Support</span>
                    <div class="status-fill" style="background-color: #ffcc00;"></div>
                </div>
                <div id="status-rapid" class="status-bar">
                    <span class="status-label">Laser Overcharge</span>
                    <div class="status-fill" style="background-color: #ff3300;"></div>
                </div>
                <div id="status-rocket" class="status-bar">
                    <span class="status-label">Homing Rockets</span>
                    <div class="status-fill" style="background-color: #ff9900;"></div>
                </div>
                <div id="status-mine" class="status-bar">
                    <span class="status-label">Plasma Mines</span>
                    <div class="status-fill" style="background-color: #cc00cc;"></div>
                </div>
            </div>
        </div>
        
        <!-- Comms Panel -->
        <div id="comms-panel">
            <div id="comms-title">Incoming Transmission</div>
            <div id="comms-text">...Decoding Subspace Signal...</div>
        </div>
        
        <div id="action-container">
            <!-- Upgrade Button (Bottom Left) -->
            <div id="upgrade-container">
                <div id="upgrade-btn-bottom">OPEN<br>SHOP</div>
                <div id="upgrade-label">Fabricator</div>
            </div>
            
            <!-- Ultimate Button -->
            <div id="ultimate-container">
                <div id="ultimate-btn">CHARGING</div>
                <div id="ultimate-label">Nova Bomb</div>
            </div>
        </div>
        
        <!-- Boss HUD -->
        <div id="boss-hud">
            <div id="boss-name">Warning: Boss Approaching</div>
            <div id="boss-health-bar">
                <div id="boss-health-fill"></div>
            </div>
        </div>
        
        <div class="lcars-bar"></div>
    </div>
    
    <div id="pause-screen">
        <div id="pause-text">SIMULATION PAUSED</div>
        <button id="resume-btn" class="btn">RESUME</button>
        <button id="mute-btn-pause" class="btn btn-secondary" style="margin-top: 20px;">Toggle Sound</button>
    </div>
    
    <!-- Instructions Screen -->
    <div id="instructions-screen">
        <div id="instructions-title">Mission Briefing</div>
        <div class="instructions-content">
            <ul>
                <li><strong>CONTROLS:</strong> Touch & Drag anywhere on screen to steer. Movement is relative to your finger.</li>
                <li><strong>COMBAT:</strong> Your ship auto-fires. Dodge enemy fire and collect power-ups from fallen ships.</li>
                <li><strong>CREDITS:</strong> Collect golden bars to buy upgrades in the FABRICATOR.</li>
                <li><strong>NOVA BOMB:</strong> When the bar is full, press the button for a screen-clearing blast.</li>
                <li><strong>OBJECTIVE:</strong> Survive the waves, defeat the Galactic Bosses, and secure the sector.</li>
                <li><strong>BONUS:</strong> Survive long enough to unlock the <strong>SIGMA 13</strong> protocol.</li>
            </ul>
        </div>
        <button id="close-instructions-btn" class="btn">UNDERSTOOD</button>
    </div>
    
    <!-- Database Screen -->
    <div id="database-screen">
        <div id="database-title">Enemy Database</div>
        <div class="database-grid" id="database-grid">
            <!-- Items populated by JS -->
        </div>
        <button id="close-database-btn" class="btn">CLOSE DATABASE</button>
    </div>
    
    <!-- Upgrade Screen -->
    <div id="upgrade-screen">
        <div id="upgrade-title">Ship Fabricator</div>
        <div id="current-latinum">Credits: 0</div>
        <div class="upgrade-grid">
            <div class="upgrade-card">
                <div class="upgrade-name">Hull Repair</div>
                <div class="upgrade-cost">Cost: 50</div>
                <div style="color:#ccc; font-size:12px; margin-bottom:5px;">Restores 50 HP</div>
                <button class="upgrade-buy-btn" onclick="buyUpgrade('repair', 50)">FABRICATE</button>
            </div>
            <div class="upgrade-card">
                <div class="upgrade-name">Shield Harmonics</div>
                <div class="upgrade-cost">Cost: 100</div>
                <div style="color:#ccc; font-size:12px; margin-bottom:5px;">+20 Max Shields</div>
                <button class="upgrade-buy-btn" onclick="buyUpgrade('maxhp', 100)">FABRICATE</button>
            </div>
            <div class="upgrade-card">
                <div class="upgrade-name">Laser Power</div>
                <div class="upgrade-cost">Cost: 200</div>
                <div style="color:#ccc; font-size:12px; margin-bottom:5px;">+1 Damage/Shot</div>
                <button class="upgrade-buy-btn" onclick="buyUpgrade('damage', 200)">FABRICATE</button>
            </div>
            <div class="upgrade-card">
                <div class="upgrade-name">Cooling Coils</div>
                <div class="upgrade-cost">Cost: 150</div>
                <div style="color:#ccc; font-size:12px; margin-bottom:5px;">+10% Fire Rate</div>
                <button class="upgrade-buy-btn" onclick="buyUpgrade('firerate', 150)">FABRICATE</button>
            </div>
        </div>
        <button id="close-upgrade-btn" class="btn">RETURN TO BATTLE</button>
    </div>

    <div id="start-screen">
        <h1>Cosmic Vanguard</h1>
        <p>Command the Vanguard Starship.</p>
        <button class="btn" id="start-btn">Engage</button>
        <div style="display:flex; gap:15px; margin-top:15px;">
            <button class="btn btn-secondary" id="instructions-btn">Instructions</button>
            <button class="btn btn-tertiary" id="database-btn">Database</button>
        </div>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1 id="game-over-title">System Critical</h1>
        
        <!-- Continue Section -->
        <div id="continue-section">
            <p style="color: #ccc; font-size: 18px;">Systems Failing...</p>
            <div id="continue-timer">15</div>
            <button class="btn" id="continue-btn">EMERGENCY RESTART</button>
            <p style="color: #888; margin-top: 10px; font-size: 14px;">Lives Remaining: <span id="lives-display" style="color: #ffcc00; font-weight:bold;">3</span></p>
        </div>

        <!-- Final Game Over Section -->
        <div id="final-options" class="hidden">
            <p id="final-score">Score: 0</p>
            <p id="best-score" style="color: #888; margin-top: 5px;">High Score: 0</p>
            <p id="new-highscore-msg" style="color: #ffcc00; font-weight: bold; display: none;">NEW HIGH SCORE!</p>
            <button class="btn" id="restart-btn">Re-Initialize</button>
            <button class="btn btn-tertiary" id="home-btn" style="margin-top: 15px;">Return to Base</button>
        </div>
    </div>

    <script>
        // --- Gemini API Config ---
        const apiKey = ""; // Provided by environment at runtime

        // HELPER FUNCTION: DRAW GLOWING DOT (Used by multiple ships)
        function glowDot(ctx, x, y, r, inner, outer) {
            const g = ctx.createRadialGradient(x, y, 0, x, y, r);
            g.addColorStop(0, inner);
            g.addColorStop(1, outer);
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        async function getGeminiTaunt(bossName) {
            if (!apiKey) {
                console.warn("API Key missing, skipping Gemini call.");
                showComms(bossName, "I will destroy you, Captain!"); // Fallback
                return;
            }

            const prompt = `You are the galactic villain ${bossName}. Give me a short, threatening, 1-sentence taunt to a Space Fleet Captain. Do not use quotes.`;
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }]
                    })
                });

                const data = await response.json();
                const text = data.candidates?.[0]?.content?.parts?.[0]?.text || "Your destruction is imminent.";
                showComms(bossName, text);
            } catch (error) {
                console.error("Gemini Error:", error);
                showComms(bossName, "Communications disrupted...");
            }
        }

        function showComms(sender, message) {
            const panel = document.getElementById('comms-panel');
            const title = document.getElementById('comms-title');
            const text = document.getElementById('comms-text');
            
            title.innerText = `INCOMING SIGNAL: ${sender}`;
            text.innerText = message;
            panel.style.display = 'flex';
            panel.style.opacity = '0';
            
            // Fade in
            requestAnimationFrame(() => {
                panel.style.opacity = '1';
            });
            
            // Hide after 5 seconds
            setTimeout(() => {
                panel.style.opacity = '0';
                setTimeout(() => panel.style.display = 'none', 500);
            }, 5000);
        }

        // --- Audio System (Synthesizer) ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;
        let isMuted = false;

        const SoundManager = {
            init: () => {
                if (!audioCtx) {
                    audioCtx = new AudioContext();
                } else if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
            },
            
            toggleMute: () => {
                isMuted = !isMuted;
                const txt = isMuted ? "SND: OFF" : "SND: ON";
                document.getElementById('mute-btn').innerText = txt;
                return isMuted;
            },
            
            playTone: (freq, type, duration, vol = 0.1) => {
                if (isMuted || !audioCtx) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            },

            shoot: () => {
                if (isMuted || !audioCtx) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.15);
                gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.15);
            },

            enemyShoot: () => {
                if (isMuted || !audioCtx) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(300, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(100, audioCtx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.03, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.2);
            },

            explode: (large = false) => {
                if (isMuted || !audioCtx) return;
                const bufferSize = audioCtx.sampleRate * (large ? 1.0 : 0.3);
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 1000;
                gain.gain.setValueAtTime(large ? 0.3 : 0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + (large ? 1.0 : 0.3));
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                noise.start();
            },
            
            powerup: () => {
                if (isMuted || !audioCtx) return;
                const now = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(660, now);
                osc.frequency.setValueAtTime(880, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 0.3);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(now + 0.3);
            },
            
            coin: () => {
                if (isMuted || !audioCtx) return;
                const now = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(1200, now);
                osc.frequency.setValueAtTime(1800, now + 0.05);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 0.1);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(now + 0.1);
            },
            
            bossAlarm: () => {
                 if (isMuted || !audioCtx) return;
                 const now = audioCtx.currentTime;
                 const osc = audioCtx.createOscillator();
                 const gain = audioCtx.createGain();
                 osc.type = 'triangle';
                 osc.frequency.setValueAtTime(400, now);
                 osc.frequency.linearRampToValueAtTime(800, now + 0.5);
                 osc.frequency.linearRampToValueAtTime(400, now + 1.0);
                 gain.gain.setValueAtTime(0.2, now);
                 gain.gain.linearRampToValueAtTime(0.01, now + 1.0);
                 osc.connect(gain);
                 gain.connect(audioCtx.destination);
                 osc.start();
                 osc.stop(now + 1.0);
            },
            
            ultimate: () => {
                 if (isMuted || !audioCtx) return;
                 const now = audioCtx.currentTime;
                 const osc = audioCtx.createOscillator();
                 const gain = audioCtx.createGain();
                 osc.type = 'sawtooth';
                 osc.frequency.setValueAtTime(100, now);
                 osc.frequency.exponentialRampToValueAtTime(800, now + 0.5);
                 osc.frequency.exponentialRampToValueAtTime(50, now + 1.5);
                 gain.gain.setValueAtTime(0.3, now);
                 gain.gain.linearRampToValueAtTime(0.01, now + 1.5);
                 osc.connect(gain);
                 gain.connect(audioCtx.destination);
                 osc.start();
                 osc.stop(now + 1.5);
            },
            
            buy: () => {
                if (isMuted || !audioCtx) return;
                const now = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.setValueAtTime(600, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 0.3);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(now + 0.3);
            }
        };
        
        // Mute Toggle Logic
        const muteHandler = () => SoundManager.toggleMute();
        document.getElementById('mute-btn').addEventListener('click', muteHandler);
        document.getElementById('mute-btn-pause').addEventListener('click', muteHandler);


        // --- Game Configuration & State ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let gameState = 'START'; 
        let score = 0;
        
        let highScore = localStorage.getItem('trek1942_highscore') || 0;
        document.getElementById('highscore-display').innerText = `High: ${highScore}`;

        let frameCount = 0;
        let difficultyMultiplier = 1;
        
        // Spawn Delay (for quiet time after boss)
        let spawnDelay = 0;

        // Continue System State
        let livesRemaining = 3;
        let continueInterval = null;
        
        // Screen Shake State
        let shakeDuration = 0;
        let shakeMagnitude = 0;
        
        // Ultimate Flash State
        let flashDuration = 0;

        // Boss State
        let bossActive = false;
        let currentBoss = null;
        let nextBossScore = 1000;
        let bossIndex = 0;
        
        // REBRANDED BOSS LIST
        const bossList = ["Vigilant Raider", "Harvester Prime", "Lattice Matron", "Quantum Anomaly", "Obsidian Monarch", "Warlord Varlis"];

        // Entity Arrays
        let player;
        let enemies = [];
        let bullets = [];
        let upgrades = [];
        let coins = []; 
        let particles = [];
        let stars = [];
        let planets = []; 
        let mines = [];
        let rockets = [];
        let floatingTexts = []; 

        // Input State
        const input = {
            x: 0,
            y: 0,
            isTouching: false
        };
        
        // Relative Touch State
        let dragStartX = 0;
        let dragStartY = 0;
        let playerStartX = 0;
        let playerStartY = 0;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (player) {
                player.x = Math.min(Math.max(player.x, player.width/2), canvas.width - player.width/2);
                player.y = Math.min(Math.max(player.y, player.height/2), canvas.height - player.height/2);
                player.targetX = player.x;
                player.targetY = player.y;
            }
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Input Listeners ---
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState !== 'PLAYING') return;
            input.isTouching = true;
            dragStartX = e.touches[0].clientX;
            dragStartY = e.touches[0].clientY;
            playerStartX = player.targetX; 
            playerStartY = player.targetY;
        }, {passive: false});

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (gameState !== 'PLAYING') return;
            const currentX = e.touches[0].clientX;
            const currentY = e.touches[0].clientY;
            const dx = currentX - dragStartX;
            const dy = currentY - dragStartY;
            player.setTarget(playerStartX + dx, playerStartY + dy);
        }, {passive: false});

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            input.isTouching = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (gameState !== 'PLAYING') return;
            if (!input.isTouching) {
                player.setTarget(e.clientX, e.clientY);
            }
        });

        canvas.addEventListener('mousedown', () => input.isTouching = true);
        canvas.addEventListener('mouseup', () => input.isTouching = false);
        
        // --- Pause Logic ---
        const pauseBtn = document.getElementById('pause-btn');
        const resumeBtn = document.getElementById('resume-btn');
        const pauseScreen = document.getElementById('pause-screen');
        
        pauseBtn.addEventListener('click', () => {
            if (gameState === 'PLAYING') {
                gameState = 'PAUSED';
                pauseScreen.style.display = 'flex';
                if(audioCtx && audioCtx.state === 'running') audioCtx.suspend();
            }
        });
        
        resumeBtn.addEventListener('click', () => {
            if (gameState === 'PAUSED') {
                gameState = 'PLAYING';
                pauseScreen.style.display = 'none';
                if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
            }
        });
        
        // --- Instructions Logic ---
        const instructionsBtn = document.getElementById('instructions-btn');
        const closeInstructionsBtn = document.getElementById('close-instructions-btn');
        const instructionsScreen = document.getElementById('instructions-screen');
        
        instructionsBtn.addEventListener('click', () => {
            instructionsScreen.style.display = 'flex';
        });
        
        closeInstructionsBtn.addEventListener('click', () => {
            instructionsScreen.style.display = 'none';
        });
        
        // --- Database Logic ---
        const databaseBtn = document.getElementById('database-btn');
        const closeDatabaseBtn = document.getElementById('close-database-btn');
        const databaseScreen = document.getElementById('database-screen');
        const databaseGrid = document.getElementById('database-grid');
        
        // REBRANDED ENEMY DATA
        const enemyData = [
            {type: 'scout', name: 'Drake Clans', desc: 'Fast attack ship. Agile but lightly armored.', hp: 1, score: 10},
            {type: 'cruiser', name: 'Eclipse Sovereignty', desc: 'Heavy warship with cloaking capabilities.', hp: 3, score: 50},
            {type: 'scarab', name: 'Shard Legion', desc: 'Swarm fighter. Relies on numbers.', hp: 4, score: 60},
            {type: 'obsidian', name: 'Sable Dominion', desc: 'Durable hull with advanced disruptors.', hp: 6, score: 80},
            {type: 'bio', name: 'Triarch Brood', desc: 'Organic bioship. Erratic and deadly.', hp: 8, score: 120},
            {type: 'cube', name: 'Lattice Node', desc: 'Massive geometric fortress. Extremely durable.', hp: 15, score: 150}
        ];
        
        // REBRANDED BOSS DATA
        const bossData = [
            {name: 'Vigilant Raider', desc: 'A hijacked heavy cruiser turned pirate flagship.', hp: 150, score: 1000},
            {name: 'Harvester Prime', desc: 'Massive mining vessel adapted for war.', hp: 250, score: 2000},
            {name: 'Lattice Matron', desc: 'The central node of the hive mind.', hp: 400, score: 3000},
            {name: 'Quantum Anomaly', desc: 'A being of pure energy and chaos.', hp: 600, score: 5000},
            {name: 'Obsidian Monarch', desc: 'The dreadnought of the Sable fleet.', hp: 750, score: 6000},
            {name: 'Warlord Varlis', desc: 'Supreme Commander. The ultimate threat.', hp: 1000, score: 10000}
        ];
        
        function generateDatabase() {
            databaseGrid.innerHTML = ''; // Clear
            
            // Render Enemies
            enemyData.forEach(data => {
                const card = document.createElement('div');
                card.className = 'enemy-card';
                
                const cvs = document.createElement('canvas');
                cvs.width = 100; cvs.height = 80;
                const c = cvs.getContext('2d');
                
                // Create dummy enemy to draw
                const dummy = new Enemy(data.type, 50, 40); 
                dummy.draw(c); // Pass the mini-context
                
                card.innerHTML = `
                    ${cvs.outerHTML}
                    <div class="enemy-name">${data.name}</div>
                    <div class="enemy-desc">${data.desc}</div>
                    <div class="enemy-stats">HP: ${data.hp} | SCORE: ${data.score}</div>
                `;
                
                // Need to redraw canvas after inserting innerHTML because simple append copies HTML string not live canvas state?
                // Actually innerHTML serialization of canvas is empty. 
                // Better to append elements.
                databaseGrid.appendChild(card);
                // Re-get canvas to draw
                const finalCvs = card.querySelector('canvas');
                const finalC = finalCvs.getContext('2d');
                dummy.draw(finalC);
            });
            
            // Render Bosses
            bossData.forEach(data => {
                const card = document.createElement('div');
                card.className = 'enemy-card';
                card.style.borderColor = '#ff3300'; // Boss styling
                
                const cvs = document.createElement('canvas');
                cvs.width = 120; cvs.height = 100;
                const c = cvs.getContext('2d');
                
                const dummy = new Boss(data.name);
                dummy.x = 60; dummy.y = 50; // Center
                dummy.draw(c);
                
                card.innerHTML = `
                    <div style="width:120px; height:100px;"></div>
                    <div class="enemy-name" style="color:#ff3300">${data.name}</div>
                    <div class="enemy-desc">${data.desc}</div>
                    <div class="enemy-stats" style="color:#ff9900">HP: ${data.hp} | SCORE: ${data.score}</div>
                `;
                
                databaseGrid.appendChild(card);
                const placeholder = card.children[0];
                placeholder.replaceWith(cvs);
                
                // Re-draw
                const finalC = cvs.getContext('2d');
                dummy.draw(finalC);
            });
        }
        
        databaseBtn.addEventListener('click', () => {
            generateDatabase();
            databaseScreen.style.display = 'flex';
        });
        
        closeDatabaseBtn.addEventListener('click', () => {
            databaseScreen.style.display = 'none';
        });
        
        // --- Upgrade UI Logic ---
        const upgradeBtnBottom = document.getElementById('upgrade-btn-bottom'); 
        const upgradeScreen = document.getElementById('upgrade-screen');
        const closeUpgradeBtn = document.getElementById('close-upgrade-btn');
        
        upgradeBtnBottom.addEventListener('click', (e) => {
            e.stopPropagation(); 
            if (gameState === 'PLAYING') {
                gameState = 'PAUSED'; 
                upgradeScreen.style.display = 'flex';
                updateUpgradeUI();
                if(audioCtx && audioCtx.state === 'running') audioCtx.suspend();
            }
        });
        
        closeUpgradeBtn.addEventListener('click', () => {
            if (gameState === 'PAUSED') {
                gameState = 'PLAYING';
                upgradeScreen.style.display = 'none';
                if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
            }
        });
        
        // Global function for HTML buttons
        window.buyUpgrade = function(type, cost) {
            if(player.coins >= cost) {
                player.coins -= cost;
                SoundManager.buy();
                
                if(type === 'repair') {
                    player.hp = Math.min(player.maxHp, player.hp + 50);
                    updateHealth();
                }
                else if(type === 'maxhp') {
                    player.maxHp += 20;
                    player.hp += 20; 
                    updateHealth();
                }
                else if(type === 'damage') {
                    player.damage += 1;
                }
                else if(type === 'firerate') {
                    player.fireRateModifier *= 0.9; 
                }
                
                updateUpgradeUI();
                document.getElementById('latinum-display').innerText = `Credits: ${player.coins}`;
            }
        }
        
        function updateUpgradeUI() {
            document.getElementById('current-latinum').innerText = `Credits: ${player.coins}`;
            const btns = document.querySelectorAll('.upgrade-buy-btn');
            btns.forEach(btn => {
                const cost = parseInt(btn.getAttribute('onclick').split(',')[1]);
                btn.disabled = player.coins < cost;
            });
        }
        
        // --- Ultimate Trigger ---
        const ultBtn = document.getElementById('ultimate-btn');
        ultBtn.addEventListener('click', (e) => {
            e.stopPropagation(); 
            if(gameState === 'PLAYING' && player && player.ultimateCharge >= player.maxUltimate) {
                triggerUltimate();
            }
        });

        function triggerShake(frames, mag) {
            shakeDuration = frames;
            shakeMagnitude = mag;
        }

        function triggerUltimate() {
            player.ultimateCharge = 0;
            updateUltimateUI();
            SoundManager.ultimate();
            triggerShake(20, 10);
            flashDuration = 20; 
            
            bullets = bullets.filter(b => !b.isEnemy);
            
            enemies.forEach(e => {
                if(e.active) {
                    e.takeDamage(50); 
                    if(!e.active) {
                        score += e.scoreVal;
                        spawnCoins(e.x, e.y, e.type === 'cube' ? 5 : 2); 
                        for(let i=0; i<8; i++) particles.push(new Particle(e.x, e.y, '#fff'));
                    }
                }
            });
            
            if(bossActive && currentBoss && currentBoss.active) {
                currentBoss.takeDamage(50);
                for(let i=0; i<15; i++) particles.push(new Particle(currentBoss.x, currentBoss.y, '#fff'));
                if(!currentBoss.active) handleBossDefeat();
            }
        }

        function updateUltimateUI() {
            if(!player) return;
            const pct = Math.floor((player.ultimateCharge / player.maxUltimate) * 100);
            if (player.ultimateCharge >= player.maxUltimate) {
                ultBtn.innerText = "FIRE";
                ultBtn.classList.add('ready');
                ultBtn.style.background = ""; 
            } else {
                ultBtn.innerText = pct + "%";
                ultBtn.classList.remove('ready');
                ultBtn.style.background = `rgba(30, 30, 30, 0.6)`;
            }
        }

        // --- Classes ---
        
        class FloatingText {
            constructor(x, y, text, color, size = 14) {
                this.x = x + (Math.random() * 20 - 10);
                this.y = y;
                this.text = text;
                this.color = color;
                this.size = size;
                this.life = 1.0; 
                this.vy = 1.5; 
            }

            update() {
                this.y -= this.vy;
                this.life -= 0.02; 
            }

            draw() {
                ctx.save();
                
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.font = `bold ${this.size}px Arial`;
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.strokeText(this.text, this.x, this.y);
                ctx.fillText(this.text, this.x, this.y);
                
                ctx.restore();
            }
        }
        
        class Coin {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 15;
                this.height = 15;
                this.vy = 3; 
                this.vx = (Math.random() - 0.5) * 2;
                this.active = true;
                this.frame = 0;
            }
            
            update() {
                this.y += this.vy;
                this.x += this.vx;
                this.frame++;
                
                const dist = Math.hypot(player.x - this.x, player.y - this.y);
                if(dist < 100) {
                    this.x += (player.x - this.x) * 0.1;
                    this.y += (player.y - this.y) * 0.1;
                }
                
                if (this.y > canvas.height + 20) this.active = false;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Spin effect
                const scaleX = Math.cos(this.frame * 0.1);
                ctx.scale(scaleX, 1);
                
                ctx.fillStyle = '#ffcc00';
                ctx.shadowBlur = 5;
                ctx.shadowColor = '#ffcc00';
                ctx.fillRect(-6, -4, 12, 8);
                ctx.strokeStyle = '#fff7cc';
                ctx.lineWidth = 1;
                ctx.strokeRect(-6, -4, 12, 8);
                ctx.restore();
            }
        }

        class Planet {
            constructor() {
                this.reset();
                this.y = Math.random() * canvas.height; 
            }

            reset() {
                this.radius = Math.random() * 40 + 20; 
                this.x = Math.random() * (canvas.width - this.radius*2) + this.radius;
                this.y = -this.radius * 2 - (Math.random() * 2000); 
                this.speed = Math.random() * 0.3 + 0.1; 
                
                const hues = [0, 200, 280, 30, 120]; 
                this.hue = hues[Math.floor(Math.random() * hues.length)];
                this.type = Math.random() > 0.5 ? 'gas' : 'terrestrial';
            }

            update() {
                this.y += this.speed * (gameState === 'PLAYING' ? 1 : 0.1);
                if (this.y > canvas.height + this.radius * 2) {
                     this.reset();
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                const grad = ctx.createRadialGradient(-this.radius*0.3, -this.radius*0.3, this.radius * 0.1, 0, 0, this.radius);
                grad.addColorStop(0, `hsla(${this.hue}, 80%, 70%, 0.3)`);
                grad.addColorStop(0.5, `hsla(${this.hue}, 60%, 50%, 0.3)`);
                grad.addColorStop(1, `hsla(${this.hue}, 60%, 20%, 0.3)`);
                
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI*2);
                ctx.fill();
                
                if (this.type === 'gas') {
                    ctx.strokeStyle = `hsla(${this.hue}, 40%, 80%, 0.1)`;
                    ctx.lineWidth = 6;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.radius * 1.6, this.radius * 0.3, Math.PI / 8, 0, Math.PI*2);
                    ctx.stroke();
                }
                
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.beginPath();
                ctx.arc(5, 5, this.radius, 0, Math.PI*2);
                ctx.fill();
                
                ctx.restore();
            }
        }

        // IMPROVEMENT 1: Warp Speed Stars
        class Star {
            constructor() {
                this.reset();
                this.y = Math.random() * canvas.height;
            }

            reset() {
                this.x = Math.random() * canvas.width;
                this.y = -10;
                // z represents depth/speed. Higher Z = closer/faster
                this.z = Math.random() * 4 + 0.5; 
                this.size = Math.max(0.5, this.z * 0.5);
                this.opacity = Math.min(1, this.z * 0.2);
            }

            update() {
                // Speed based on Z index for parallax
                this.y += Math.pow(this.z, 2) * (gameState === 'PLAYING' ? 1 : 0.1); 
                if (this.y > canvas.height) this.reset();
            }

            draw() {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
                ctx.beginPath();
                // Draw as a streak based on speed
                const length = this.z * 5; 
                ctx.rect(this.x, this.y, this.size, length);
                ctx.fill();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                // Add friction and drag for better feel
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 4 + 1;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.decay = Math.random() * 0.03 + 0.02;
                this.size = Math.random() * 3 + 1;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.95; // Drag
                this.vy *= 0.95;
                this.life -= this.decay;
                this.size *= 0.95; // Shrink
            }

            draw() {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class Upgrade {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vy = 2;
                this.width = 30;
                this.height = 30;
                this.active = true;
                this.wobble = Math.random() * Math.PI * 2;
                
                const r = Math.random();
                if (r < 0.2) this.type = 'SHIELD';
                else if (r < 0.4) this.type = 'WINGMAN';
                else if (r < 0.6) this.type = 'RAPID';
                else if (r < 0.8) this.type = 'ROCKET';
                else this.type = 'MINE';
            }

            update() {
                this.y += this.vy;
                this.wobble += 0.1;
                this.x += Math.sin(this.wobble) * 0.5; // Slight drift
                if (this.y > canvas.height + 50) this.active = false;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.shadowBlur = 10;
                
                let color = '#fff';
                let label = '?';
                
                if (this.type === 'SHIELD') { color = '#00aaff'; label = 'S'; }
                else if (this.type === 'WINGMAN') { color = '#ffcc00'; label = 'W'; }
                else if (this.type === 'RAPID') { color = '#ff3300'; label = 'F'; }
                else if (this.type === 'ROCKET') { color = '#ff9900'; label = 'R'; }
                else if (this.type === 'MINE') { color = '#cc00cc'; label = 'M'; }
                
                ctx.fillStyle = color;
                ctx.shadowColor = color;
                ctx.beginPath();
                ctx.arc(0, 0, 15, 0, Math.PI*2);
                ctx.fill();
                
                // Inner ring
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, 10, 0, Math.PI*2);
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(label, 0, 1);
                
                ctx.restore();
            }
        }

        class Mine {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 20;
                this.height = 20;
                this.active = true;
                this.blink = 0;
            }

            update() {
                this.y -= 3; 
                this.blink++;
                if (this.y < -50) this.active = false;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.fillStyle = (Math.floor(this.blink / 10) % 2 === 0) ? '#cc00cc' : '#ff00ff';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#cc00cc';
                
                ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                    let angle = (i / 8) * Math.PI * 2;
                    ctx.lineTo(Math.cos(angle) * 10, Math.sin(angle) * 10);
                    ctx.lineTo(Math.cos(angle + 0.4) * 5, Math.sin(angle + 0.4) * 5);
                }
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
        }

        class Rocket {
            constructor(x, y, isEnemy = false) {
                this.x = x;
                this.y = y;
                this.width = 10;
                this.height = 20;
                this.active = true;
                this.target = null;
                this.speed = 8;
                this.angle = -Math.PI / 2;
                this.isEnemy = isEnemy; // Track if this is hostile
                
                // If enemy, point down initially
                if (this.isEnemy) this.angle = Math.PI / 2; 
            }

            update() {
                // Target Selection
                if (this.isEnemy) {
                    this.target = player;
                } 
                else if (!this.target || !this.target.active) {
                    let closest = null;
                    let minDist = Infinity;
                    
                    if (bossActive && currentBoss) {
                        this.target = currentBoss;
                    } else {
                        enemies.forEach(e => {
                            if (!e.active) return;
                            const dist = Math.hypot(e.x - this.x, e.y - this.y);
                            if (dist < minDist) {
                                minDist = dist;
                                closest = e;
                            }
                        });
                        this.target = closest;
                    }
                }

                // Homing Logic
                if (this.target && this.target.active) {
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const targetAngle = Math.atan2(dy, dx);
                    
                    let diff = targetAngle - this.angle;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    
                    // Turn speed
                    this.angle += diff * 0.08;
                }

                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                
                // Trail particles
                if (Math.random() < 0.5) {
                    let color = this.isEnemy ? '#d0f' : '#ff9900';
                    particles.push(new Particle(this.x, this.y, color));
                }

                if (this.y < -50 || this.y > canvas.height + 50 || this.x < -50 || this.x > canvas.width + 50) {
                    this.active = false;
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle + Math.PI/2); 
                
                if (this.isEnemy) {
                    // Purple Enemy Missile
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(-3, -10, 6, 15);
                    ctx.fillStyle = '#d0f'; // Purple thruster
                    ctx.fillRect(-3, 5, 6, 5);
                } else {
                    // Player Missile
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(-3, -10, 6, 15);
                    ctx.fillStyle = '#ff9900';
                    ctx.fillRect(-3, 5, 6, 5); 
                }
                
                ctx.restore();
            }
        }

        class Bullet {
            constructor(x, y, isEnemy, vx = 0, vy = 0, color = null, size = 4) {
                this.x = x;
                this.y = y;
                this.isEnemy = isEnemy;
                this.width = size;
                this.height = size * 3; 
                
                if (vx === 0 && vy === 0) {
                    this.vx = 0;
                    this.vy = isEnemy ? 7 : -12;
                    this.height = 15; 
                    this.width = 4;
                } else {
                    this.vx = vx;
                    this.vy = vy;
                    if (size > 5) this.height = size; 
                }

                this.active = true;
                this.color = color; 
                this.isOrb = (Math.abs(this.width - this.height) < 2); 
                this.isDiamond = false; // New shape flag
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                
                if (this.y < -50 || this.y > canvas.height + 50 || this.x < -50 || this.x > canvas.width + 50) {
                    this.active = false;
                }
            }

            draw() {
                ctx.save();
                
                if (this.isDiamond) {
                    // DIAMOND SHAPE WEAPON (Void Empress)
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = this.color || '#d0f';
                    ctx.fillStyle = this.color || '#fff';
                    
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y - this.width); // Top
                    ctx.lineTo(this.x + this.width, this.y); // Right
                    ctx.lineTo(this.x, this.y + this.width); // Bottom
                    ctx.lineTo(this.x - this.width, this.y); // Left
                    ctx.closePath();
                    ctx.fill();
                }
                else if (this.isOrb || this.width > 6) {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = this.color || '#d0f';
                    ctx.fillStyle = this.color || '#fff';
                    
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.width/2, 0, Math.PI*2);
                    ctx.fill();
                } 
                else {
                    // Standard Beams
                    if (this.color) {
                         ctx.fillStyle = this.color;
                         ctx.shadowBlur = 5;
                         ctx.shadowColor = this.color;
                    } else if (this.isEnemy) {
                        ctx.fillStyle = '#00ff00';
                        ctx.shadowBlur = 5;
                        ctx.shadowColor = '#00ff00';
                    } else {
                        ctx.fillStyle = '#ffaa00';
                        ctx.shadowBlur = 5;
                        ctx.shadowColor = '#ffaa00';
                    }
                    ctx.fillRect(this.x - this.width/2, this.y, this.width, this.height);
                }
                ctx.restore();
            }
        }

        class Ship {
            constructor(x, y, hp) {
                this.x = x;
                this.y = y;
                this.hp = hp;
                this.maxHp = hp;
                this.width = 40;
                this.height = 40;
                this.active = true;
                this.flashTimer = 0;
                this.shieldHitTimer = 0; // New: For shield ripple effect
                this.invincible = false; // New: For respawn
            }

            takeDamage(amount) {
                if (this.invincible) return; // Ignore damage if invincible

                this.hp -= amount;
                this.flashTimer = 5;
                if(this.isPlayer) this.shieldHitTimer = 10; // Trigger shield ripple
                
                let color = '#fff';
                let size = 14;
                
                if (this.isPlayer) {
                    color = '#ff3333'; 
                    size = 16;
                } else if (amount > 5) {
                    color = '#ffcc00'; 
                    size = 20;
                }
                
                if (gameState === 'PLAYING') {
                    floatingTexts.push(new FloatingText(this.x, this.y - 20, "-" + Math.floor(amount), color, size));
                }
                
                if (this.hp <= 0) {
                    this.explode();
                    this.active = false;
                }
            }

            explode() {
                for(let i=0; i<15; i++) {
                    particles.push(new Particle(this.x, this.y, this.isPlayer ? '#00aaff' : '#ffaa00'));
                }
            }
        }

        class Player extends Ship {
            constructor() {
                super(canvas.width / 2, canvas.height - 100, 100);
                this.isPlayer = true;
                this.width = 60;
                this.height = 70;
                this.lastShot = 0;
                this.fireRate = 25; // Buff: Slightly faster base fire rate (was 30)
                
                this.coins = 0;
                this.damage = 1; 
                this.fireRateModifier = 1.0; 
                
                this.wingmanTimer = 0;
                this.rapidTimer = 0;
                this.rocketTimer = 0;
                this.mineTimer = 0;
                this.maxTimer = 600;
                
                this.ultimateCharge = 0;
                this.maxUltimate = 100;
                
                // Bonus Level Transformation State
                this.isProtector = false; 
            }

            setTarget(tx, ty) {
                this.targetX = tx;
                this.targetY = ty;
            }

            activateUpgrade(type) {
                if (type === 'SHIELD') {
                    this.hp = Math.min(this.maxHp, this.hp + 50);
                    updateHealth();
                } 
                else if (type === 'WINGMAN') this.wingmanTimer += this.maxTimer; 
                else if (type === 'RAPID') this.rapidTimer += this.maxTimer; 
                else if (type === 'ROCKET') this.rocketTimer += this.maxTimer; 
                else if (type === 'MINE') this.mineTimer += this.maxTimer; 
                
                updateTimersUI();
            }

            update() {
                if (this.targetX !== undefined) {
                    this.x += (this.targetX - this.x) * 0.15;
                    this.y += (this.targetY - this.y) * 0.15;
                }

                this.x = Math.max(this.width/2, Math.min(canvas.width - this.width/2, this.x));
                this.y = Math.max(this.height/2, Math.min(canvas.height - this.height/2, this.y));

                // Ultimate Charge
                if (this.ultimateCharge < this.maxUltimate) {
                    this.ultimateCharge += 0.04; 
                    if (this.ultimateCharge >= this.maxUltimate) {
                        this.ultimateCharge = this.maxUltimate;
                        updateUltimateUI(); 
                    } else if (frameCount % 30 === 0) {
                        updateUltimateUI();
                    }
                }

                const prog = Math.min(bossIndex, 5);
                const currentBaseRate = (30 - (prog * 3)) * this.fireRateModifier;
                const currentRapidRate = (16 - (prog * 1.6)) * this.fireRateModifier;

                if (this.rapidTimer > 0) {
                    this.rapidTimer--;
                    this.fireRate = currentRapidRate;
                } else {
                    this.fireRate = currentBaseRate;
                }
                
                if (this.wingmanTimer > 0) this.wingmanTimer--;
                if (this.rocketTimer > 0) this.rocketTimer--;
                if (this.mineTimer > 0) this.mineTimer--;

                if (frameCount - this.lastShot > this.fireRate) {
                    this.shoot();
                    this.lastShot = frameCount;
                }
                
                const rocketRate = 60 - (prog * 6);
                if (this.rocketTimer > 0 && frameCount % Math.floor(rocketRate) === 0) {
                    rockets.push(new Rocket(this.x, this.y));
                }
                
                const mineRate = 90 - (prog * 9);
                if (this.mineTimer > 0 && frameCount % Math.floor(mineRate) === 0) {
                    mines.push(new Mine(this.x, this.y - 30));
                }
                
                // Engine Trails
                if (frameCount % 3 === 0) {
                    particles.push(new Particle(this.x - 20, this.y + 30, '#00d4ff'));
                    particles.push(new Particle(this.x + 20, this.y + 30, '#00d4ff'));
                }

                if (this.flashTimer > 0) this.flashTimer--;
                if (this.shieldHitTimer > 0) this.shieldHitTimer--;
                
                // Handle Invincibility Visuals (Blinking)
                if (this.invincible) {
                    if (frameCount % 10 < 5) this.flashTimer = 2;
                }

                if (frameCount % 5 === 0) updateTimersUI();
            }

            shoot() {
                SoundManager.shoot(); 
                bullets.push(new Bullet(this.x - 15, this.y - 20, false));
                bullets.push(new Bullet(this.x + 15, this.y - 20, false));
                
                if (this.wingmanTimer > 0) {
                    bullets.push(new Bullet(this.x - 50, this.y, false));
                    bullets.push(new Bullet(this.x + 50, this.y, false));
                }
            }

            drawWingman(offsetX) {
                ctx.save();
                ctx.translate(offsetX, 10);
                ctx.scale(0.6, 0.6);
                ctx.fillStyle = '#ddd';
                ctx.beginPath();
                ctx.moveTo(0, -30);
                ctx.lineTo(15, 10);
                ctx.lineTo(10, 20);
                ctx.lineTo(-10, 20);
                ctx.lineTo(-15, 10);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = '#0099ff';
                ctx.fillRect(-12, 10, 4, 10);
                ctx.fillRect(8, 10, 4, 10);
                ctx.restore();
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                // IMPROVEMENT 3: Shield Ripple Effect
                if (this.shieldHitTimer > 0) {
                    ctx.beginPath();
                    ctx.strokeStyle = `rgba(0, 212, 255, ${this.shieldHitTimer / 10})`;
                    ctx.lineWidth = 3;
                    ctx.arc(0, 0, 50 + (10 - this.shieldHitTimer) * 2, 0, Math.PI*2);
                    ctx.stroke();
                    ctx.fillStyle = `rgba(0, 212, 255, ${this.shieldHitTimer / 20})`;
                    ctx.fill();
                }

                if (this.flashTimer > 0) ctx.globalCompositeOperation = 'source-atop'; 

                // --- DRAW PLAYER SHIP ---
                if (this.isProtector) {
                    // ARCSHIP PROTECTOR (Vector Fleet v5)
                    ctx.scale(1.18 * 0.8, 1 * 0.8); // lengthen slightly more, reduce size
                    
                    const bodyGrad = ctx.createLinearGradient(0, -64, 0, 60);
                    bodyGrad.addColorStop(0, "#f7fbff");
                    bodyGrad.addColorStop(0.3, "#dde6ff");
                    bodyGrad.addColorStop(1, "#7b87bb");
                    ctx.fillStyle = bodyGrad;
                    ctx.beginPath();
                    ctx.moveTo(0, -64);
                    ctx.lineTo(26, -34);
                    ctx.bezierCurveTo(34, -16, 36, 8, 32, 38);
                    ctx.bezierCurveTo(28, 58, 14, 68, 0, 70);
                    ctx.bezierCurveTo(-14, 68, -28, 58, -32, 38);
                    ctx.bezierCurveTo(-36, 8, -34, -16, -26, -34);
                    ctx.closePath();
                    ctx.fill();

                    glowDot(ctx, 0, -32, 7, "#ffffff", "rgba(185,205,255,0.3)");

                    ctx.fillStyle = "#1c74ff";
                    ctx.beginPath();
                    ctx.moveTo(-4, -60);
                    ctx.lineTo(4, -60);
                    ctx.lineTo(6, 50);
                    ctx.lineTo(-6, 50);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = "#c1ccef";
                    ctx.beginPath();
                    ctx.moveTo(-18, -4);
                    ctx.lineTo(-76, 10);
                    ctx.lineTo(-32, 32);
                    ctx.lineTo(-10, 16);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(18, -4);
                    ctx.lineTo(76, 10);
                    ctx.lineTo(32, 32);
                    ctx.lineTo(10, 16);
                    ctx.closePath();
                    ctx.fill();

                    const podGrad = ctx.createLinearGradient(0, 12, 0, 52);
                    podGrad.addColorStop(0, "#7f8aa9");
                    podGrad.addColorStop(1, "#3b425c");
                    ctx.fillStyle = podGrad;
                    ctx.beginPath();
                    ctx.rect(-34, 16, 10, 30); // roundRect compatibility fallback
                    ctx.rect(24, 16, 10, 30);
                    ctx.fill();

                    glowDot(ctx, -29, 48, 4.3, "#43d7ff", "rgba(0,194,255,0.18)");
                    glowDot(ctx,  29, 48, 4.3, "#43d7ff", "rgba(0,194,255,0.18)");
                } 
                else {
                    // SOLARIS VANGUARD (Vector Fleet v5)
                    // Ship Hull
                    const hullGrad = ctx.createRadialGradient(0, -8, 8, 0, 0, 52);
                    hullGrad.addColorStop(0, "#f9fbff");
                    hullGrad.addColorStop(0.4, "#c0c8de");
                    hullGrad.addColorStop(1, "#6f778f");
                    ctx.fillStyle = hullGrad;
                    ctx.beginPath();
                    ctx.moveTo(0, -46);
                    ctx.lineTo(26, -32);
                    ctx.bezierCurveTo(40, -18, 40, 4, 36, 24);
                    ctx.bezierCurveTo(30, 42, 16, 54, 0, 58);
                    ctx.bezierCurveTo(-16, 54, -30, 42, -36, 24);
                    ctx.bezierCurveTo(-40, 4, -40, -18, -26, -32);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = "#8f97b2";
                    ctx.beginPath();
                    ctx.moveTo(-30, -10);
                    ctx.lineTo(-54, -2);
                    ctx.lineTo(-38, 16);
                    ctx.lineTo(-22, 6);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(30, -10);
                    ctx.lineTo(54, -2);
                    ctx.lineTo(38, 16);
                    ctx.lineTo(22, 6);
                    ctx.closePath();
                    ctx.fill();

                    glowDot(ctx, -44, 10, 4, "#ff6666", "rgba(255,0,0,0.12)");
                    glowDot(ctx,  44, 10, 4, "#ff6666", "rgba(255,0,0,0.12)");

                    const defGrad = ctx.createLinearGradient(0, -48, 0, -22);
                    defGrad.addColorStop(0, "#f7e2bf");
                    defGrad.addColorStop(1, "#b17237");
                    ctx.fillStyle = defGrad;
                    ctx.beginPath();
                    ctx.moveTo(-12, -40);
                    ctx.lineTo(12, -40);
                    ctx.lineTo(6, -26);
                    ctx.lineTo(-6, -26);
                    ctx.closePath();
                    ctx.fill();

                    glowDot(ctx, 0, -18, 5, "#ffffff", "rgba(220,228,255,0.25)");

                    ctx.strokeStyle = "rgba(40,45,70,0.7)";
                    ctx.lineWidth = 1.4;
                    ctx.beginPath();
                    ctx.moveTo(-18, -2); ctx.lineTo(18, -2);
                    ctx.moveTo(-16, 12); ctx.lineTo(16, 14);
                    ctx.stroke();
                }

                if (this.flashTimer > 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.beginPath();
                    ctx.arc(0, 0, 40, 0, Math.PI*2);
                    ctx.fill();
                }
                
                if (this.wingmanTimer > 0) {
                    this.drawWingman(-50);
                    this.drawWingman(50);
                }

                ctx.restore();
            }
        }

        class Enemy extends Ship {
            constructor(type, startX = null, startY = null) {
                // Use provided start coords or random
                super(startX || Math.random() * (canvas.width - 40) + 20, startY || -50, 1);
                this.type = type; 
                
                this.vy = Math.random() * 1.5 + 1 + (difficultyMultiplier * 0.3);
                this.vx = Math.sin(this.y * 0.01) * 2; 
                this.swing = Math.random() * 0.05;
                
                // DIFFICULTY ADJUSTMENT: HP REDUCED BY ~50%
                if (type === 'cube') { // Lattice Node
                    this.hp = 8 * difficultyMultiplier; 
                    this.width = 70;
                    this.height = 70;
                    this.scoreVal = 150;
                    this.vy = 0.5 + (difficultyMultiplier * 0.1);
                } else if (type === 'bio') { // Triarch Brood
                    this.hp = 4 * difficultyMultiplier; 
                    this.width = 40;
                    this.height = 55;
                    this.scoreVal = 120;
                    this.vy = 3 + (difficultyMultiplier * 0.5); 
                    this.swing = 0.2; 
                } else if (type === 'obsidian') { // Sable Dominion
                    this.hp = 3 * difficultyMultiplier; 
                    this.width = 60;
                    this.height = 70;
                    this.scoreVal = 80;
                    this.vy = 1.2 + (difficultyMultiplier * 0.1); 
                } else if (type === 'scarab') { // Shard Legion
                    this.hp = 2 * difficultyMultiplier; 
                    this.width = 35;
                    this.height = 40;
                    this.scoreVal = 60;
                    this.vy = 2.5 + (difficultyMultiplier * 0.2); 
                } else if (type === 'cruiser') { // Eclipse Sovereignty
                    this.hp = 2 * difficultyMultiplier; 
                    this.width = 72;
                    this.height = 48;
                    this.scoreVal = 50;
                } else { // Drake Clans
                    this.hp = 1 * difficultyMultiplier; 
                    this.width = 48;
                    this.height = 48;
                    this.scoreVal = 10;
                }
            }

            update() {
                this.y += this.vy;
                
                // Bio-ships move more erratically
                if(this.type === 'bio') {
                     this.x += Math.sin(frameCount * 0.1) * 5;
                } else {
                     this.x += Math.sin(frameCount * this.swing) * 2;
                }

                const prog = Math.min(bossIndex, 5);
                // DIFFICULTY ADJUSTMENT: Reduced Enemy Fire Rate
                const baseChance = 0.0008 + (prog * 0.0002); // Was 0.0015 + ...

                if (Math.random() < baseChance * difficultyMultiplier) {
                    SoundManager.enemyShoot(); 
                    bullets.push(new Bullet(this.x, this.y + 20, true));
                }

                if (this.y > canvas.height + 50) this.active = false;
                if (this.flashTimer > 0) this.flashTimer--;
            }

            // Allow passing in a context for preview rendering
            draw(c = ctx) {
                c.save();
                c.translate(this.x, this.y);
                
                // Standard rotation for most, bio rotates with path
                if (this.type === 'bio') {
                   // c.scale(1.0, 1.0);
                } else {
                   c.scale(1.0, -1.0); // Flip vertically to face down
                   c.scale(1, -1); // Re-flip because new art assumes top-down is negative Y? 
                   // Actually, new art assumes (0,0) center. 
                   // Let's check orientation. Ships face UP in the provided code (y is negative).
                   // Enemies need to face DOWN.
                   c.rotate(Math.PI); 
                }

                if (this.flashTimer > 0) c.globalAlpha = 0.7;
                
                // Scale factor to fit existing hitboxes
                let scale = 0.6; 

                if (this.type === 'cube') {
                    // LATTICE NODE
                    c.scale(scale, scale);
                    c.fillStyle = "#111518";
                    c.fillRect(-36, -36, 72, 72);

                    c.fillStyle = "#070a0b";
                    c.beginPath();
                    c.moveTo(36, -36);
                    c.lineTo(54, -26);
                    c.lineTo(54, 26);
                    c.lineTo(36, 36);
                    c.closePath();
                    c.fill();

                    c.strokeStyle = "#244c24";
                    c.lineWidth = 1.3;
                    c.beginPath();
                    for (let i = -30; i <= 30; i += 8) {
                      if (i % 16 !== 0) {
                        c.moveTo(i, -36); c.lineTo(i, 36);
                      }
                      c.moveTo(-36, i); c.lineTo(36, i);
                    }
                    c.stroke();

                    const pulse = 0.5 + 0.4 * Math.sin(frameCount * 0.12);
                    c.shadowColor = "#25ff3e";
                    c.shadowBlur = 18;
                    c.strokeStyle = `rgba(80,255,120,${pulse})`;
                    c.lineWidth = 3;
                    c.strokeRect(-33, -33, 66, 66);
                    c.shadowBlur = 0;
                } 
                else if (this.type === 'cruiser') {
                    // ECLIPSE SOVEREIGNTY
                    c.scale(scale, scale);
                    const ringGrad = c.createLinearGradient(0, -48, 0, 42);
                    ringGrad.addColorStop(0, "#368a55");
                    ringGrad.addColorStop(1, "#173b26");
                    c.fillStyle = ringGrad;
                    c.beginPath();
                    c.moveTo(-78, 4);
                    c.bezierCurveTo(-66, -30, -32, -50, 10, -46);
                    c.bezierCurveTo(46, -42, 76, -16, 80, 10);
                    c.bezierCurveTo(72, 32, 44, 42, 12, 46);
                    c.bezierCurveTo(-26, 50, -60, 36, -78, 4);
                    c.closePath();
                    c.fill();

                    c.save();
                    c.globalCompositeOperation = "destination-out";
                    c.beginPath();
                    c.moveTo(-32, 4);
                    c.bezierCurveTo(-22, -12, -4, -20, 12, -18);
                    c.bezierCurveTo(26, -16, 40, -6, 46, 8);
                    c.bezierCurveTo(40, 22, 26, 30, 12, 32);
                    c.bezierCurveTo(-6, 34, -22, 26, -32, 10);
                    c.closePath();
                    c.fill();
                    c.restore();

                    c.fillStyle = "#132b1d";
                    c.beginPath();
                    c.moveTo(18, -20);
                    c.lineTo(30, -10);
                    c.lineTo(20, -6);
                    c.closePath();
                    c.fill();
                    c.beginPath();
                    c.moveTo(10, -22);
                    c.lineTo(18, -12);
                    c.lineTo(8, -8);
                    c.closePath();
                    c.fill();

                    glowDot(c, 6, 4, 3.2, "#e8ffe8", "rgba(100,255,150,0.4)");
                    glowDot(c, 18, 6, 3.2, "#e8ffe8", "rgba(100,255,150,0.4)");
                } 
                else if (this.type === 'bio') {
                    // TRIARCH BROOD
                    c.scale(scale, scale);
                    c.rotate(Math.PI); // Face down
                    const bioGrad = c.createRadialGradient(-6, -18, 4, 0, 0, 60);
                    bioGrad.addColorStop(0, "#ffe9cf");
                    bioGrad.addColorStop(0.4, "#d3955c");
                    bioGrad.addColorStop(1, "#5b3120");
                    c.fillStyle = bioGrad;

                    c.beginPath();
                    c.moveTo(-4, -40);
                    c.quadraticCurveTo(-30, -8, -40, 18);
                    c.quadraticCurveTo(-26, 30, -16, 40);
                    c.quadraticCurveTo(-10, 26, -4, 6);
                    c.closePath();
                    c.fill();

                    c.beginPath();
                    c.moveTo(4, -40);
                    c.quadraticCurveTo(30, -8, 40, 20);
                    c.quadraticCurveTo(26, 32, 16, 42);
                    c.quadraticCurveTo(10, 26, 4, 6);
                    c.closePath();
                    c.fill();

                    c.beginPath();
                    c.moveTo(-6, 8);
                    c.quadraticCurveTo(0, 40, 0, 56);
                    c.quadraticCurveTo(0, 40, 6, 8);
                    c.closePath();
                    c.fill();

                    c.strokeStyle = "rgba(255,236,200,0.8)";
                    c.lineWidth = 2;
                    c.beginPath();
                    c.moveTo(0, 54);
                    c.lineTo(0, 0);
                    c.stroke();
                }
                else if (this.type === 'obsidian') {
                    // SABLE DOMINION
                    c.scale(scale, scale);
                    const hullGrad = c.createLinearGradient(0, -80, 0, 46);
                    hullGrad.addColorStop(0, "#f3c98e");
                    hullGrad.addColorStop(0.45, "#d39a55");
                    hullGrad.addColorStop(1, "#7c5328");
                    c.fillStyle = hullGrad;

                    c.beginPath();
                    c.moveTo(0, -80);
                    c.lineTo(9, -38);
                    c.lineTo(46, -16);
                    c.lineTo(38, 22);
                    c.quadraticCurveTo(0, 48, -38, 22);
                    c.lineTo(-46, -16);
                    c.lineTo(-9, -38);
                    c.closePath();
                    c.fill();

                    c.strokeStyle = "rgba(110,70,30,0.9)";
                    c.lineWidth = 2;
                    c.beginPath();
                    c.moveTo(0, -78);
                    c.lineTo(0, 30);
                    c.stroke();

                    c.fillStyle = "#c4873b";
                    c.beginPath();
                    c.moveTo(0, -38);
                    c.lineTo(14, -20);
                    c.lineTo(0, -12);
                    c.lineTo(-14, -20);
                    c.closePath();
                    c.fill();

                    glowDot(c, 0, 30, 4.2, "#ff4a2d", "rgba(255,80,40,0.25)");
                }
                else if (this.type === 'scarab') {
                    // SHARD LEGION
                    c.scale(scale, scale);
                    const hullGrad = c.createRadialGradient(0, -10, 8, 0, 0, 52);
                    hullGrad.addColorStop(0, "#f4d9ff");
                    hullGrad.addColorStop(0.35, "#b57be2");
                    hullGrad.addColorStop(1, "#33233d");
                    c.fillStyle = hullGrad;

                    c.beginPath();
                    c.moveTo(0, -46);
                    c.lineTo(24, -32);
                    c.lineTo(36, -10);
                    c.lineTo(32, 16);
                    c.lineTo(20, 36);
                    c.lineTo(0, 46);
                    c.lineTo(-20, 36);
                    c.lineTo(-32, 16);
                    c.lineTo(-36, -10);
                    c.lineTo(-24, -32);
                    c.closePath();
                    c.fill();

                    c.strokeStyle = "rgba(255,235,255,0.6)";
                    c.lineWidth = 1.3;
                    c.beginPath();
                    c.moveTo(0, -46); c.lineTo(0, 46);
                    c.moveTo(-22, -20); c.lineTo(0, -10); c.lineTo(22, -20);
                    c.moveTo(-18, 6); c.lineTo(0, 18); c.lineTo(18, 6);
                    c.stroke();

                    glowDot(c, -10, -20, 3.1, "#ff6cff", "rgba(255,120,255,0.35)");
                    glowDot(c,  10, -20, 3.1, "#ff6cff", "rgba(255,120,255,0.35)");
                }
                else {
                    // DRAKE CLANS (Default)
                    c.scale(scale, scale);
                    const hullGrad = c.createLinearGradient(-80, -10, 80, 20);
                    hullGrad.addColorStop(0, "#304027");
                    hullGrad.addColorStop(0.5, "#4c6b3e");
                    hullGrad.addColorStop(1, "#2a3a23");
                    c.fillStyle = hullGrad;

                    c.beginPath();
                    c.moveTo(0, -32);
                    c.lineTo(20, -14);
                    c.lineTo(70, -4);
                    c.lineTo(90, 16);
                    c.lineTo(34, 18);
                    c.lineTo(10, 34);
                    c.lineTo(-10, 34);
                    c.lineTo(-34, 18);
                    c.lineTo(-90, 16);
                    c.lineTo(-70, -4);
                    c.lineTo(-20, -14);
                    c.closePath();
                    c.fill();

                    c.strokeStyle = "rgba(10,15,8,0.7)";
                    c.lineWidth = 2;
                    c.beginPath();
                    c.moveTo(0, -30);
                    c.lineTo(0, 30);
                    c.stroke();

                    glowDot(c, -86, 14, 3.2, "#ff4646", "rgba(255,0,0,0.25)");
                    glowDot(c,  86, 14, 3.2, "#ff4646", "rgba(255,0,0,0.25)");
                }
                c.restore();
            }
        }

        class Boss extends Ship {
            constructor(name) {
                super(canvas.width / 2, -100, 500);
                this.name = name;
                this.width = 120;
                this.height = 100;
                this.targetY = 100;
                this.phase = 0;
                this.isBoss = true;

                // DIFFICULTY ADJUSTMENT: Boss HP Reduced by 50%
                if (name === "Vigilant Raider") {
                    this.hp = 150; this.maxHp = 150; this.scoreVal = 1000; 
                    this.width = 160; this.height = 100; 
                } else if (name === "Harvester Prime") {
                    this.hp = 250; this.maxHp = 250; this.scoreVal = 2000; 
                    this.width = 180; this.height = 100; 
                } else if (name === "Lattice Matron") {
                    this.hp = 400; this.maxHp = 400; this.scoreVal = 3000; 
                    this.width = 100; this.height = 180; 
                } else if (name === "Quantum Anomaly") {
                    this.hp = 600; this.maxHp = 600; this.scoreVal = 5000; 
                } else if (name === "Obsidian Monarch") {
                    this.hp = 750; this.maxHp = 750; this.scoreVal = 6000; 
                    this.width = 200; this.height = 150; 
                } else if (name === "Warlord Varlis") {
                    // BONUS BOSS
                    this.hp = 1000; this.maxHp = 1000; this.scoreVal = 10000;
                    this.width = 180; this.height = 140; 
                }
            }

            update() {
                if (this.y < this.targetY) {
                    this.y += 1;
                } else {
                    this.x += Math.sin(frameCount * 0.02) * 3;
                    if (this.name === "Quantum Anomaly" && Math.random() < 0.01) {
                        this.x = Math.random() * (canvas.width - 100) + 50;
                    }
                }

                this.x = Math.max(this.width/2, Math.min(canvas.width - this.width/2, this.x));

                const prog = Math.min(bossIndex, 5);
                // DIFFICULTY ADJUSTMENT: Reduced Boss Fire Rate
                let chance = 0.015 + (prog * 0.002); 

                if (Math.random() < chance) {
                      if (this.name !== "Obsidian Monarch") {
                        SoundManager.enemyShoot(); 
                        bullets.push(new Bullet(this.x, this.y + this.height/2, true));
                      }
                      
                      if (this.name === "Harvester Prime" || this.name === "Lattice Matron") {
                          let b1 = new Bullet(this.x - 20, this.y + this.height/2, true);
                          b1.vx = -2;
                          let b2 = new Bullet(this.x + 20, this.y + this.height/2, true);
                          b2.vx = 2;
                          bullets.push(b1, b2);
                      } 
                      else if (this.name === "Obsidian Monarch") {
                          // NEW: Pink Diamond Shots
                          SoundManager.enemyShoot();
                          let b = new Bullet(this.x, this.y + this.height/2, true);
                          b.isDiamond = true; 
                          b.width = 12; // Large size
                          b.color = '#f0f'; // Bright Pink
                          b.vy = 6 + difficultyMultiplier; // Speed
                          bullets.push(b);

                          // NEW: Periodic Hunter Seeker Missiles
                          if (Math.random() < 0.15) {
                              let m = new Rocket(this.x, this.y, true); // isEnemy = true
                              rockets.push(m);
                          }
                      }
                      else if (this.name === "Warlord Varlis") {
                          // Placeholder firing logic for Zarris
                          SoundManager.enemyShoot();
                          let b = new Bullet(this.x, this.y + this.height/2, true);
                          b.color = '#0f0'; // Green plasma
                          b.speed = 7;
                          bullets.push(b);
                      }
                }

                if (this.flashTimer > 0) this.flashTimer--;
                updateBossUI(this);
            }

            draw(c = ctx) {
                c.save();
                c.translate(this.x, this.y);
                if (this.flashTimer > 0) c.globalAlpha = 0.7;
                
                // Orientation fix: Bosses need to face down
                c.scale(1.0, -1.0);
                c.rotate(Math.PI); 

                let scale = 0.8; 
                
                // --- MERGED BOSS ART ---
                
                if (this.name === "Vigilant Raider") {
                    c.scale(scale, scale);
                    const saucerGrad = c.createRadialGradient(0, -4, 8, 0, 0, 54);
                    saucerGrad.addColorStop(0, "#ffffff");
                    saucerGrad.addColorStop(1, "#8c94a4");
                    c.fillStyle = saucerGrad;
                    c.beginPath();
                    c.ellipse(0, 0, 54, 42, 0, 0, Math.PI * 2);
                    c.fill();

                    c.fillStyle = "#8d93a1";
                    c.fillRect(-68, -30, 136, 11);

                    c.fillStyle = "#d4d9e3";
                    c.beginPath();
                    c.moveTo(-28, -30);
                    c.lineTo(-22, -52);
                    c.lineTo(22, -52);
                    c.lineTo(28, -30);
                    c.closePath();
                    c.fill();
                    glowDot(c, 0, -44, 10, "#ff4b4b", "rgba(255,0,0,0.22)");

                    c.fillStyle = "#767d8f";
                    c.fillRect(-58, 10, 11, 44);
                    c.fillRect( 47, 10, 11, 44);
                } 
                else if (this.name === "Harvester Prime") {
                    c.scale(scale, scale);
                    c.fillStyle = "#160707";
                    c.beginPath();
                    c.ellipse(0, 0, 15, 11, 0.3, 0, Math.PI * 2);
                    c.fill();

                    for (let i = 0; i < 9; i++) {
                      const a = (i / 9) * Math.PI * 2 + frameCount * 0.02;
                      const x2 = Math.cos(a) * (70 + (i % 3) * 6);
                      const y2 = Math.sin(a) * (70 + (i % 3) * 6);
                      const g = c.createLinearGradient(0, 0, x2, y2);
                      g.addColorStop(0, "#2a1300");
                      g.addColorStop(1, "#ff9b28");
                      c.strokeStyle = g;
                      c.lineWidth = 3.6;
                      c.lineCap = "round";
                      c.beginPath();
                      c.moveTo(0, 0);
                      c.lineTo(x2, y2);
                      c.stroke();
                    }
                }
                else if (this.name === "Lattice Matron") {
                    c.scale(scale, scale);
                    const diamondGrad = c.createLinearGradient(0, -84, 0, 84);
                    diamondGrad.addColorStop(0, "#2e3235");
                    diamondGrad.addColorStop(0.5, "#050607");
                    diamondGrad.addColorStop(1, "#262a2d");
                    c.fillStyle = diamondGrad;
                    c.beginPath();
                    c.moveTo(0, -84);
                    c.lineTo(68, 0);
                    c.lineTo(0, 84);
                    c.lineTo(-68, 0);
                    c.closePath();
                    c.fill();

                    glowDot(c, 0, -70, 4, "#4bff88", "rgba(0,255,128,0.25)");
                    glowDot(c, 56, 0, 4, "#4bff88", "rgba(0,255,128,0.25)");
                    glowDot(c, 0, 70, 4, "#4bff88", "rgba(0,255,128,0.25)");
                    glowDot(c, -56, 0, 4, "#4bff88", "rgba(0,255,128,0.25)");

                    const pulse = 0.55 + 0.4 * Math.sin(frameCount * 0.14);
                    c.shadowColor = "#27ff5b";
                    c.shadowBlur = 20;
                    c.strokeStyle = `rgba(90,255,150,${pulse})`;
                    c.lineWidth = 3;
                    c.stroke();
                    c.shadowBlur = 0;

                    glowDot(c, 0, 0, 14, "#4bff88", "rgba(0,255,128,0.35)");
                }
                else if (this.name === "Quantum Anomaly") {
                    c.scale(scale, scale);
                    c.save();
                    c.globalCompositeOperation = "lighter";

                    const coreGrad = c.createRadialGradient(0, 0, 5, 0, 0, 56);
                    coreGrad.addColorStop(0, "#ffffff");
                    coreGrad.addColorStop(0.35, "#ff66ff");
                    coreGrad.addColorStop(1, "rgba(0,0,0,0)");
                    c.fillStyle = coreGrad;
                    c.beginPath();
                    c.arc(0, 0, 64, 0, Math.PI * 2);
                    c.fill();

                    c.strokeStyle = "rgba(220,220,255,0.95)";
                    c.lineWidth = 4;
                    const start = frameCount * 0.14;
                    c.beginPath();
                    c.arc(0, 0, 44, start, start + Math.PI * 1.25);
                    c.stroke();

                    c.restore();
                }
                else if (this.name === "Obsidian Monarch") {
                    c.scale(scale, scale);
                    const hullGrad = c.createRadialGradient(0, -10, 10, 0, 0, 72);
                    hullGrad.addColorStop(0, "#ffd6ff");
                    hullGrad.addColorStop(0.45, "#c058cf");
                    hullGrad.addColorStop(1, "#311235");
                    c.fillStyle = hullGrad;
                    c.beginPath();
                    c.moveTo(0, -62);
                    c.bezierCurveTo(40, -50, 68, -10, 54, 42);
                    c.bezierCurveTo(32, 76, -32, 76, -54, 42);
                    c.bezierCurveTo(-68, -10, -40, -50, 0, -62);
                    c.closePath();
                    c.fill();

                    glowDot(c, -22, -6, 5, "#ff8cff", "rgba(255,130,255,0.35)");
                    glowDot(c,  22, -6, 5, "#ff8cff", "rgba(255,130,255,0.35)");

                    c.strokeStyle = "rgba(255,160,255,0.35)";
                    c.lineWidth = 3;
                    c.beginPath();
                    c.ellipse(0, 6, 70, 60, 0, 0, Math.PI * 2);
                    c.stroke();
                }
                else if (this.name === "Warlord Varlis") {
                    c.scale(scale, scale);
                    const sGrad = c.createLinearGradient(0, -80, 0, 80);
                    sGrad.addColorStop(0, "#2b3c18");
                    sGrad.addColorStop(1, "#050803");
                    c.fillStyle = sGrad;
                    c.beginPath();
                    c.moveTo(0, -80);
                    c.lineTo(90, -28);
                    c.lineTo(56, 72);
                    c.lineTo(0, 52);
                    c.lineTo(-56, 72);
                    c.lineTo(-90, -28);
                    c.closePath();
                    c.fill();

                    c.fillStyle = "#151d09";
                    c.beginPath();
                    c.moveTo(-90, -28);
                    c.lineTo(-108, -6);
                    c.lineTo(-64, 2);
                    c.closePath();
                    c.fill();
                    c.beginPath();
                    c.moveTo(90, -28);
                    c.lineTo(108, -6);
                    c.lineTo(64, 2);
                    c.closePath();
                    c.fill();

                    glowDot(c, -26, -12, 4.4, "#c3ff3a", "rgba(170,255,60,0.4)");
                    glowDot(c,  26, -12, 4.4, "#c3ff3a", "rgba(170,255,60,0.4)");
                }

                c.restore();
            }
        }

        // --- Game Logic Functions ---

        // IMPROVEMENT 2: Formations / Squads
        function spawnEnemies() {
            if (bossActive || spawnDelay > 0) return; 

            // DIFFICULTY ADJUSTMENT: Reduced Spawn Rate
            // Base chance for random spawns (Reduced from 0.01)
            if (Math.random() < 0.006 * difficultyMultiplier) {
                 enemies.push(new Enemy(getRandomEnemyType()));
            }
            
            // Chance for a Squad (Reduced from 0.005)
            if (Math.random() < 0.003 * difficultyMultiplier) {
                spawnSquadron();
            }
        }
        
        function getRandomEnemyType() {
            const rand = Math.random();
            
            // Phase 1: Early Game (0-1 Bosses defeated)
            if (bossIndex < 2) {
                // Small chance to see a Cube early (Level 2)
                if (bossIndex === 1 && rand > 0.97) return 'cube'; 
                if (bossIndex === 1 && rand > 0.90) return 'obsidian';
                return rand > 0.7 ? 'cruiser' : 'scout';
            }
            
            // Phase 2: Mid Game (2-3 Bosses defeated)
            if (bossIndex < 4) {
                if (rand > 0.90) return 'cube';     // 10% chance (Lattice Node)
                if (rand > 0.75) return 'obsidian'; // 15% chance (Sable Dominion)
                if (rand > 0.30) return 'scarab';   // 45% chance (Shard Legion)
                return 'cruiser';                   // 30% chance
            }
            
            // Phase 3: Late Game (4+ Bosses defeated)
            if (rand > 0.80) return 'cube';     // 20% chance (Increased from 10%)
            if (rand > 0.60) return 'bio';      // 20% chance (Triarch Brood)
            if (rand > 0.30) return 'obsidian'; // 30% chance
            return 'scarab';                    // 30% chance
        }
        
        function spawnSquadron() {
            // Squads can now be Scouts or Scarabs depending on difficulty
            const type = (bossIndex > 2 && Math.random() > 0.5) ? 'scarab' : 'scout';
            const pattern = Math.random() > 0.5 ? 'V' : 'LINE';
            const startX = Math.random() * (canvas.width - 200) + 100;
            
            if (pattern === 'V') {
                enemies.push(new Enemy(type, startX, -50));
                enemies.push(new Enemy(type, startX - 40, -80));
                enemies.push(new Enemy(type, startX + 40, -80));
            } else {
                enemies.push(new Enemy(type, startX, -50));
                enemies.push(new Enemy(type, startX + 50, -50));
                enemies.push(new Enemy(type, startX - 50, -50));
            }
        }
        
        function spawnCoins(x, y, amount) {
            for(let i=0; i<amount; i++) {
                coins.push(new Coin(x, y));
            }
        }

        function checkBossSpawn() {
            if (!bossActive && score >= nextBossScore && spawnDelay === 0) {
                bossActive = true;
                SoundManager.bossAlarm(); 
                let name = bossList[bossIndex % bossList.length];
                currentBoss = new Boss(name);
                
                document.getElementById('boss-hud').style.display = 'flex';
                document.getElementById('boss-name').innerText = "WARNING: " + name;
                
                getGeminiTaunt(name);
                
                // BONUS LEVEL TRIGGER
                if (name === "Warlord Varlis") {
                    activateBonusLevel();
                }
            }
        }
        
        function activateBonusLevel() {
            // Transform Player Logic
            player.isProtector = true;
            // Full heal for the bonus round
            player.hp = player.maxHp; 
            updateHealth();
            
            // Visual Flare
            showComms("COMMAND", "SIGMA 13 ACTIVATED. SHIP RECONFIGURING.");
            triggerShake(20, 5);
            
            // Could change background or music here in future
        }
        
        function updateBossUI(boss) {
            const fill = document.getElementById('boss-health-fill');
            const pct = Math.max(0, (boss.hp / boss.maxHp) * 100);
            fill.style.width = pct + "%";
        }

        function spawnUpgrades() {
            if (Math.random() < 0.002) {
                upgrades.push(new Upgrade(Math.random() * (canvas.width - 60) + 30, -30));
            }
        }

        function checkCollisions() {
            // 1. Bullets
            bullets.forEach(b => {
                if (!b.active) return;
                
                if (!b.isEnemy) {
                    let hitBoss = false;
                    if (bossActive && currentBoss) {
                        if (Math.abs(b.x - currentBoss.x) < currentBoss.width/2 && Math.abs(b.y - currentBoss.y) < currentBoss.height/2) {
                            b.active = false;
                            hitBoss = true;
                            currentBoss.takeDamage(player.damage); 
                            triggerShake(3, 2); 
                            if (!currentBoss.active) handleBossDefeat();
                        }
                    } 
                    
                    if (!hitBoss) {
                        enemies.forEach(e => {
                            if (!e.active || !b.active) return;
                            if (Math.abs(b.x - e.x) < e.width/2 && Math.abs(b.y - e.y) < e.height/2) {
                                b.active = false;
                                e.takeDamage(player.damage); 
                                if (!e.active) {
                                    score += e.scoreVal;
                                    spawnCoins(e.x, e.y, e.type === 'cube' ? 5 : e.type === 'cruiser' ? 2 : 1);
                                    SoundManager.explode(); 
                                }
                            }
                        });
                    }
                } else {
                    if (Math.abs(b.x - player.x) < player.width/2 - 10 && Math.abs(b.y - player.y) < player.height/2) {
                        b.active = false;
                        player.takeDamage(10);
                        triggerShake(15, 10); 
                        updateHealth();
                    }
                }
            });

            // 2. Rockets
            rockets.forEach(r => {
                if (!r.active) return;
                
                // NEW: Enemy Rocket hitting Player
                if (r.isEnemy) {
                    if (Math.hypot(r.x - player.x, r.y - player.y) < player.width/2 + 5) {
                        r.active = false;
                        player.takeDamage(20); // Heavy damage
                        triggerShake(15, 10); 
                        SoundManager.explode(); 
                        updateHealth();
                        // Particle explosion
                        for(let i=0; i<8; i++) particles.push(new Particle(r.x, r.y, '#d0f'));
                    }
                    return; // Skip enemy checks for enemy rockets
                }

                // Player Rocket Logic (Hitting Boss/Enemies)
                let hitBoss = false;
                if (bossActive && currentBoss) {
                     if (Math.hypot(r.x - currentBoss.x, r.y - currentBoss.y) < currentBoss.width/2) {
                        r.active = false;
                        hitBoss = true;
                        currentBoss.takeDamage(5 * player.damage); 
                        for(let i=0; i<5; i++) particles.push(new Particle(r.x, r.y, '#ff9900'));
                        triggerShake(8, 5); 
                        SoundManager.explode(); 
                        if (!currentBoss.active) handleBossDefeat();
                    }
                } 
                
                if (!hitBoss) {
                    enemies.forEach(e => {
                        if (!e.active || !r.active) return;
                        if (Math.hypot(r.x - e.x, r.y - e.y) < e.width/2 + 10) {
                            r.active = false;
                            e.takeDamage(10 * player.damage); 
                            for(let i=0; i<5; i++) particles.push(new Particle(r.x, r.y, '#ff9900'));
                            triggerShake(5, 3); 
                            if (!e.active) {
                                score += e.scoreVal;
                                spawnCoins(e.x, e.y, e.type === 'cube' ? 5 : 1);
                                SoundManager.explode(); 
                            }
                        }
                    });
                }
            });

            // 3. Mines
            mines.forEach(m => {
                if (!m.active) return;
                
                let hitBoss = false;
                if (bossActive && currentBoss) {
                     if (Math.abs(m.x - currentBoss.x) < currentBoss.width/2 && Math.abs(m.y - currentBoss.y) < currentBoss.height/2) {
                        m.active = false;
                        hitBoss = true;
                        currentBoss.takeDamage(20 * player.damage);
                        for(let i=0; i<10; i++) particles.push(new Particle(m.x, m.y, '#cc00cc'));
                        triggerShake(12, 8); 
                        SoundManager.explode(true); 
                        if (!currentBoss.active) handleBossDefeat();
                    }
                } 
                
                if (!hitBoss) {
                    enemies.forEach(e => {
                        if (!e.active || !m.active) return;
                        if (Math.abs(m.x - e.x) < e.width/2 + 10 && Math.abs(m.y - e.y) < e.height/2 + 10) {
                            m.active = false;
                            e.takeDamage(50 * player.damage); 
                            for(let i=0; i<10; i++) particles.push(new Particle(m.x, m.y, '#cc00cc'));
                            triggerShake(8, 5);
                            if (!e.active) {
                                score += e.scoreVal;
                                spawnCoins(e.x, e.y, 3);
                                SoundManager.explode(true); 
                            }
                        }
                    });
                }
            });

            document.getElementById('score-display').innerText = `Score: ${score}`;

            // Boss vs Player
            if (bossActive && currentBoss) {
                 if (Math.abs(currentBoss.x - player.x) < (player.width + currentBoss.width)/2.5 && Math.abs(currentBoss.y - player.y) < (player.height + currentBoss.height)/2.5) {
                     player.takeDamage(5); 
                     triggerShake(5, 5);
                     updateHealth();
                 }
            }

            // Enemies vs Player
            enemies.forEach(e => {
                if (!e.active) return;
                if (Math.abs(e.x - player.x) < (player.width + e.width)/3 && Math.abs(e.y - player.y) < (player.height + e.height)/3) {
                    e.takeDamage(100); 
                    player.takeDamage(20); 
                    triggerShake(15, 10); 
                    SoundManager.explode(true); 
                    updateHealth();
                }
            });
            
            // Upgrades
            upgrades.forEach(u => {
                if (!u.active) return;
                const dx = player.x - u.x;
                const dy = player.y - u.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < (player.width/2 + u.width/2)) {
                    u.active = false;
                    SoundManager.powerup(); 
                    player.activateUpgrade(u.type);
                }
            });
            
            // Coins
            coins.forEach(c => {
                if (!c.active) return;
                const dx = player.x - c.x;
                const dy = player.y - c.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < (player.width/2 + c.width/2)) {
                    c.active = false;
                    SoundManager.coin();
                    player.coins++;
                    document.getElementById('latinum-display').innerText = `Credits: ${player.coins}`;
                }
            });
        }
        
        function handleBossDefeat() {
            triggerShake(60, 20); 
            SoundManager.explode(true); 
            score += currentBoss.scoreVal;
            spawnCoins(currentBoss.x, currentBoss.y, 30); 
            
            // Check if we just defeated the Obsidian Monarch (Boss 5)
            if (currentBoss.name === "Obsidian Monarch") {
                setTimeout(() => activateBonusLevel(), 1000); // Transform after 1s delay
            }

            bossActive = false;
            currentBoss = null;
            bossIndex++;
            nextBossScore = score + 1000; 
            
            // REDUCED DELAY: Changed from 1200 (20s) to 180 (3s)
            spawnDelay = 180;
            
            document.getElementById('boss-hud').style.display = 'none';
            player.hp = Math.min(player.maxHp, player.hp + 50);
            updateHealth();
        }

        function updateHealth() {
            const pct = Math.max(0, Math.ceil((player.hp / player.maxHp) * 100));
            document.getElementById('health-display').innerText = `Shields: ${pct}%`;
            document.getElementById('health-display').style.color = pct < 30 ? '#ff3300' : '#00d4ff';
            
            if (player.hp <= 0) {
                endGame();
            }
        }
        
        function updateTimersUI() {
            const wingmanBar = document.getElementById('status-wingman');
            const rapidBar = document.getElementById('status-rapid');
            const rocketBar = document.getElementById('status-rocket');
            const mineBar = document.getElementById('status-mine');
            
            const updateBar = (bar, timer) => {
                if (timer > 0) {
                    bar.style.display = 'block';
                    bar.querySelector('.status-fill').style.width = (timer / player.maxTimer * 100) + '%';
                } else {
                    bar.style.display = 'none';
                }
            };
            
            updateBar(wingmanBar, player.wingmanTimer);
            updateBar(rapidBar, player.rapidTimer);
            updateBar(rocketBar, player.rocketTimer);
            updateBar(mineBar, player.mineTimer);
        }

        function initGame() {
            score = 0;
            frameCount = 0;
            difficultyMultiplier = 1;
            spawnDelay = 0; 
            
            // Reset Lives on Fresh Start
            livesRemaining = 3;
            
            bossActive = false;
            bossIndex = 0;
            nextBossScore = 1000;
            currentBoss = null;
            document.getElementById('boss-hud').style.display = 'none';
            document.getElementById('new-highscore-msg').style.display = 'none';

            enemies = [];
            bullets = [];
            particles = [];
            upgrades = [];
            coins = [];
            rockets = [];
            mines = [];
            planets = []; 
            floatingTexts = []; 
            
            player = new Player();
            player.x = canvas.width / 2;
            player.y = canvas.height - 100;
            player.targetX = player.x;
            player.targetY = player.y;
            // Ensure player starts as normal ship
            player.isProtector = false;
            
            updateUltimateUI();
            document.getElementById('score-display').innerText = `Score: 0`;
            document.getElementById('latinum-display').innerText = `Credits: 0`;
            updateHealth();
            updateTimersUI();
            
            stars = [];
            for(let i=0; i<150; i++) stars.push(new Star());
            for(let i=0; i<3; i++) planets.push(new Planet());
        }

        function endGame() {
            gameState = 'GAMEOVER';
            document.getElementById('game-over-screen').classList.remove('hidden');
            document.getElementById('ui-layer').classList.add('hidden');
            document.getElementById('boss-hud').style.display = 'none';

            // Check if we have lives left
            if (livesRemaining > 0) {
                startContinuePhase();
            } else {
                showFinalGameOver();
            }
        }

        function startContinuePhase() {
            document.getElementById('game-over-title').innerText = "CRITICAL FAILURE";
            document.getElementById('continue-section').classList.remove('hidden');
            document.getElementById('final-options').classList.add('hidden');
            document.getElementById('lives-display').innerText = livesRemaining;
            
            let timeLeft = 15;
            const timerEl = document.getElementById('continue-timer');
            const btn = document.getElementById('continue-btn');
            
            timerEl.innerText = timeLeft;
            timerEl.style.color = '#00d4ff';
            btn.disabled = false;
            btn.style.opacity = "1";

            if (continueInterval) clearInterval(continueInterval);
            
            continueInterval = setInterval(() => {
                timeLeft--;
                timerEl.innerText = timeLeft;
                
                if (timeLeft <= 5) {
                    timerEl.style.color = '#ff3300'; // Urgent red
                    SoundManager.playTone(200, 'square', 0.1); // Beep
                }

                if (timeLeft <= 0) {
                    clearInterval(continueInterval);
                    showFinalGameOver();
                }
            }, 1000);
        }

        function showFinalGameOver() {
            if (continueInterval) clearInterval(continueInterval);
            
            document.getElementById('game-over-title').innerText = "MISSION FAILED";
            document.getElementById('continue-section').classList.add('hidden');
            document.getElementById('final-options').classList.remove('hidden');

            if (score > highScore) {
                highScore = score;
                localStorage.setItem('trek1942_highscore', highScore);
                document.getElementById('highscore-display').innerText = `High: ${highScore}`;
                document.getElementById('new-highscore-msg').style.display = 'block';
            } else {
                document.getElementById('new-highscore-msg').style.display = 'none';
            }
            
            document.getElementById('final-score').innerText = `Final Score: ${score}`;
            document.getElementById('best-score').innerText = `High Score: ${highScore}`;
        }

        // Continue Button Listener
        document.getElementById('continue-btn').addEventListener('click', () => {
            if (continueInterval) clearInterval(continueInterval);
            livesRemaining--;
            
            // Respawn Logic
            gameState = 'PLAYING';
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('ui-layer').classList.remove('hidden');
            
            // Restore Boss HUD if Active
            if (bossActive && currentBoss) {
                document.getElementById('boss-hud').style.display = 'flex';
            }
            
            // 1. Heal Player
            player.hp = player.maxHp;
            player.active = true;
            player.x = canvas.width / 2;
            player.y = canvas.height - 100;
            player.targetX = player.x;
            player.targetY = player.y;
            
            // 2. Grant temporary invincibility (3 seconds)
            player.invincible = true;
            setTimeout(() => {
                if(player) player.invincible = false;
            }, 3000);

            // 3. Clear immediate threats (Optional but fair)
            bullets = []; // Clear all bullets
            enemies.forEach(e => e.takeDamage(500)); // Nuke screen slightly
            
            updateHealth();
            SoundManager.powerup(); // Play a sound for respawn
        });

        function gameLoop() {
            requestAnimationFrame(gameLoop);

            ctx.save();
            if (shakeDuration > 0) {
                const dx = (Math.random() - 0.5) * shakeMagnitude;
                const dy = (Math.random() - 0.5) * shakeMagnitude;
                ctx.translate(dx, dy);
                shakeDuration--;
            }

            if (flashDuration > 0) {
                ctx.fillStyle = '#fff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                flashDuration--;
                ctx.restore();
                return;
            }

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw Warp Stars
            stars.forEach(s => {
                s.update();
                s.draw();
            });
            
            // Draw Planets
            planets.forEach(p => {
                p.update();
                p.draw();
            });

            if (gameState === 'PLAYING') {
                frameCount++;
                if (spawnDelay > 0) spawnDelay--;
                if (frameCount % 1200 === 0) difficultyMultiplier += 0.05;

                player.update();
                player.draw();

                checkBossSpawn();
                spawnEnemies();
                spawnUpgrades();

                if (bossActive && currentBoss) {
                    currentBoss.update();
                    currentBoss.draw();
                }

                enemies.forEach(e => e.update());
                enemies.forEach(e => e.draw());
                enemies = enemies.filter(e => e.active);

                upgrades.forEach(u => u.update());
                upgrades.forEach(u => u.draw());
                upgrades = upgrades.filter(u => u.active);
                
                coins.forEach(c => c.update());
                coins.forEach(c => c.draw());
                coins = coins.filter(c => c.active);

                bullets.forEach(b => b.update());
                bullets.forEach(b => b.draw());
                bullets = bullets.filter(b => b.active);
                
                rockets.forEach(r => r.update());
                rockets.forEach(r => r.draw());
                rockets = rockets.filter(r => r.active);

                mines.forEach(m => m.update());
                mines.forEach(m => m.draw());
                mines = mines.filter(m => m.active);

                particles.forEach(p => p.update());
                particles.forEach(p => p.draw());
                particles = particles.filter(p => p.life > 0);
                
                floatingTexts.forEach(t => {
                    t.update();
                    t.draw();
                });
                floatingTexts = floatingTexts.filter(t => t.life > 0);

                checkCollisions();
            }
            
            ctx.restore();
        }

        document.getElementById('start-btn').addEventListener('click', () => {
            SoundManager.init(); 
            initGame();
            gameState = 'PLAYING';
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('ui-layer').classList.remove('hidden');
        });

        document.getElementById('restart-btn').addEventListener('click', () => {
            SoundManager.init(); 
            initGame();
            gameState = 'PLAYING';
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('ui-layer').classList.remove('hidden');
        });
        
        // New Listener for Home Button
        document.getElementById('home-btn').addEventListener('click', () => {
            gameState = 'START'; // Reset state logic
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('start-screen').classList.remove('hidden');
            // UI Layer is already hidden by endGame()
        });

        // Initialize stars/planets for background
        for(let i=0; i<150; i++) stars.push(new Star());
        for(let i=0; i<3; i++) planets.push(new Planet());
        gameLoop();

    </script>
</body>
</html>