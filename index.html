<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- PWA & Mobile Settings -->
    <title>Cosmic Vanguard: Stellar Defense</title>
    <meta name="description" content="A retro-style space shooter game. Defeat alien fleets and upgrade your ship.">
    <meta name="theme-color" content="#000000">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="./manifest.json">
    
    <!-- Favicon (Browser Tab) -->
    <link rel="icon" type="image/png" href="./icon.png">
    
    <!-- Apple Touch Icon (iOS Home Screen) - MUST be PNG -->
    <link rel="apple-touch-icon" href="./icon.png">

    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden; /* Prevent scrolling */
            touch-action: none; /* Prevent default touch gestures */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            pointer-events: auto;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }

        .hud-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #00d4ff; /* Sci-fi blue */
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
            text-shadow: 0 0 5px #00d4ff;
            width: 100%;
        }

        /* HUD Buttons */
        .hud-btn {
            background: rgba(0, 20, 40, 0.6);
            border: 1px solid #00d4ff;
            color: #00d4ff;
            padding: 6px 12px;
            border-radius: 15px 0 15px 0; /* Sci-fi angle */
            cursor: pointer;
            font-size: 12px;
            pointer-events: auto;
            text-transform: uppercase;
            font-weight: bold;
            transition: all 0.2s;
        }
        
        .hud-btn:active {
            background: #00d4ff;
            color: #000;
        }
        
        .status-container {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 4px;
            pointer-events: none;
            margin-top: 5px;
        }

        .status-bar {
            height: 4px;
            width: 80px;
            background: rgba(0,0,0,0.5);
            border: 1px solid #555;
            display: none; /* Hidden by default */
            position: relative;
            overflow: hidden; 
        }

        .status-fill {
            height: 100%;
            width: 100%;
            transition: width 0.1s linear;
        }

        .status-label {
            font-size: 9px;
            color: #fff;
            position: absolute;
            top: -10px;
            left: 0;
            opacity: 0.8;
        }
        
        /* Action Buttons Container (Bottom) */
        #action-container {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            pointer-events: none; /* Let touches pass through gaps */
        }

        /* Ultimate Button */
        #ultimate-container {
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 20;
        }

        #ultimate-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(30, 30, 30, 0.6);
            border: 2px solid #555;
            color: #888;
            font-weight: bold;
            font-size: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            box-shadow: 0 0 10px #000;
            backdrop-filter: blur(4px);
            cursor: not-allowed;
            transition: all 0.3s;
            text-shadow: none;
            user-select: none;
        }

        #ultimate-btn.ready {
            background: radial-gradient(circle, rgba(255, 51, 0, 0.8), rgba(153, 0, 0, 0.8));
            border-color: #ff9900;
            color: #fff;
            box-shadow: 0 0 20px #ff3300;
            cursor: pointer;
            animation: pulse 1.5s infinite;
        }
        
        #ultimate-label {
            margin-top: 4px;
            color: #888;
            font-size: 10px;
            text-transform: uppercase;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
            background: rgba(0,0,0,0.5);
            padding: 2px 4px;
            border-radius: 4px;
        }
        
        /* Upgrade Button */
        #upgrade-container {
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 20;
        }

        #upgrade-btn-bottom {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(68, 51, 0, 0.6);
            border: 2px solid #ffcc00;
            color: #ffcc00;
            font-weight: bold;
            font-size: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            box-shadow: 0 0 10px #ffcc00;
            backdrop-filter: blur(4px);
            cursor: pointer;
            transition: all 0.2s;
            text-shadow: none;
            user-select: none;
        }
        
        #upgrade-btn-bottom:active {
            transform: scale(0.95);
            background: #ffcc00;
            color: #000;
        }

        #upgrade-label {
            margin-top: 4px;
            color: #ffcc00;
            font-size: 10px;
            text-transform: uppercase;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
            background: rgba(0,0,0,0.5);
            padding: 2px 4px;
            border-radius: 4px;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 15px #ff3300; }
            50% { transform: scale(1.1); box-shadow: 0 0 30px #ff3300; }
            100% { transform: scale(1); box-shadow: 0 0 15px #ff3300; }
        }
        
        /* Boss HUD */
        #boss-hud {
            position: absolute;
            top: 100px; 
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            min-width: 150px; 
            display: none; 
            flex-direction: column;
            align-items: center;
            z-index: 5;
            opacity: 0.9;
        }
        
        #boss-name {
            color: #ff3300;
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
            text-shadow: 0 0 5px #ff0000;
            margin-bottom: 3px;
            letter-spacing: 1px;
            background-color: rgba(0,0,0,0.7);
            padding: 2px 8px;
            border: 1px solid #ff3300;
            border-radius: 10px;
            white-space: nowrap;
        }
        
        #boss-health-bar {
            width: 100%;
            height: 6px;
            background: #330000;
            border: 1px solid #ff3300; 
            border-radius: 3px;
            overflow: hidden;
            box-shadow: 0 0 5px #ff0000;
        }
        
        #boss-health-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff3300, #ff9900);
            transition: width 0.2s;
        }
        
        /* Comms Panel (Gemini) */
        #comms-panel {
            position: absolute;
            top: 140px;
            width: 80%;
            max-width: 400px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 20, 40, 0.9);
            border: 1px solid #00d4ff;
            border-left: 5px solid #00d4ff;
            border-radius: 5px;
            padding: 10px;
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 4;
            transition: opacity 0.5s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        #comms-title {
            color: #ff9900;
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 5px;
            animation: blink 1s infinite;
            width: 100%;
            border-bottom: 1px solid rgba(255, 153, 0, 0.3);
            padding-bottom: 3px;
        }
        #comms-text {
            color: #fff;
            font-style: italic;
            text-align: center;
            font-size: 14px;
            line-height: 1.4;
            text-shadow: 0 0 2px #00d4ff;
        }
        
        @keyframes blink { 50% { opacity: 0.5; } }
        
        /* Pause, Instructions, Upgrade & Database Overlays */
        #pause-screen, #upgrade-screen, #instructions-screen, #database-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 30;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }
        
        #pause-text, #upgrade-title, #instructions-title, #database-title {
            color: #00d4ff;
            font-size: 30px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 5px;
            text-shadow: 0 0 10px #00d4ff;
            margin-bottom: 20px;
            text-align: center;
        }
        
        /* Instructions Content */
        .instructions-content {
            color: #ccc;
            width: 80%;
            max-width: 500px;
            text-align: left;
            font-size: 16px;
            line-height: 1.6;
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid #00d4ff;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .instructions-content strong {
            color: #ffcc00;
        }
        
        .instructions-content ul {
            padding-left: 20px;
            margin: 0;
        }
        
        .instructions-content li {
            margin-bottom: 10px;
        }
        
        /* Upgrade Grid */
        .upgrade-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            width: 90%;
            max-width: 500px;
            margin-bottom: 20px;
        }
        
        .upgrade-card {
            background: linear-gradient(135deg, rgba(0, 50, 100, 0.5), rgba(0, 20, 40, 0.8));
            border: 1px solid #00d4ff;
            border-radius: 10px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            transition: transform 0.2s;
        }
        
        .upgrade-card:hover {
            border-color: #fff;
            transform: translateY(-2px);
        }
        
        .upgrade-name { color: #fff; font-weight: bold; margin-bottom: 5px; font-size: 14px; }
        .upgrade-cost { color: #ffcc00; font-size: 14px; margin-bottom: 10px; }
        .upgrade-buy-btn {
            background: #cc3333;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            width: 100%;
        }
        .upgrade-buy-btn:disabled {
            background: #555;
            color: #888;
            cursor: not-allowed;
        }
        
        #current-latinum {
            color: #ffcc00;
            font-size: 24px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff9900;
        }
        
        /* Database Grid */
        .database-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            width: 90%;
            max-width: 700px;
            max-height: 60vh;
            overflow-y: auto;
            padding: 10px;
            margin-bottom: 20px;
        }
        
        .enemy-card {
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid #555;
            border-radius: 5px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        
        .enemy-card canvas {
            margin-bottom: 10px;
            background: rgba(0,0,0,0.5);
            border-radius: 5px;
        }
        
        .enemy-name { color: #ff9900; font-weight: bold; font-size: 14px; margin-bottom: 3px; text-transform: uppercase; }
        .enemy-desc { color: #ccc; font-size: 11px; margin-bottom: 5px; font-style: italic; line-height: 1.2; }
        .enemy-stats { color: #00d4ff; font-size: 10px; }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(20,20,30,0.9), rgba(0,0,0,1));
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 10;
        }

        h1 {
            color: #ff9900; /* Sci-fi orange */
            font-size: 40px;
            margin-bottom: 10px;
            text-align: center;
            text-shadow: 0 0 20px #ff9900;
            letter-spacing: 2px;
        }

        p {
            color: #ccc;
            text-align: center;
            max-width: 80%;
            line-height: 1.5;
        }

        .btn {
            margin-top: 15px;
            padding: 15px 40px;
            background: #cc3333; /* Sci-fi red */
            color: white;
            border: none;
            border-radius: 25px; 
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 15px #cc3333;
            transition: transform 0.1s, box-shadow 0.2s;
        }

        .btn:active {
            transform: scale(0.95);
        }
        
        .btn:hover {
            box-shadow: 0 0 25px #ff3333;
        }
        
        .btn-secondary {
            background: #0066cc;
            box-shadow: 0 0 15px #0066cc;
            font-size: 18px;
            padding: 10px 30px;
        }
        
        .btn-secondary:hover {
            box-shadow: 0 0 25px #0099ff;
        }
        
        .btn-tertiary {
            background: #444;
            box-shadow: 0 0 10px #444;
            font-size: 16px;
            padding: 10px 25px;
        }
        
        .btn-tertiary:hover {
            background: #666;
            box-shadow: 0 0 15px #666;
        }

        .hidden {
            display: none !important;
        }

        /* Continue Screen Styles */
        #continue-timer {
            font-size: 60px;
            color: #00d4ff;
            font-weight: bold;
            text-shadow: 0 0 20px #00d4ff;
            margin: 10px 0;
            animation: pulse-timer 1s infinite;
        }

        @keyframes pulse-timer {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* LCARS decorative bars */
        .lcars-bar {
            height: 10px;
            background: linear-gradient(90deg, #ff9900 20%, #cc3333 50%, #99ccff 80%);
            width: 100%;
            position: absolute;
            bottom: 0;
            opacity: 0.8;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="hud-row">
                <button id="pause-btn" class="hud-btn">PAUSE</button>
                <div id="score-display">0</div>
                <button id="mute-btn" class="hud-btn">SND: ON</button>
            </div>
            <div class="hud-row" style="justify-content: center; margin-top: -5px;">
                 <div id="highscore-display" style="color: #888; font-size: 12px;">High: 0</div>
            </div>
            <div class="hud-row" style="justify-content: space-between; margin-top: 5px; padding: 0 5px;">
                <div id="latinum-display" style="color: #ffcc00; font-weight: bold;">Credits: 0</div>
                <div id="health-display">Shields: 100%</div>
            </div>
            
            <div class="status-container">
                <div id="status-wingman" class="status-bar">
                    <span class="status-label">Fighter Support</span>
                    <div class="status-fill" style="background-color: #ffcc00;"></div>
                </div>
                <div id="status-rapid" class="status-bar">
                    <span class="status-label">Laser Overcharge</span>
                    <div class="status-fill" style="background-color: #ff3300;"></div>
                </div>
                <div id="status-rocket" class="status-bar">
                    <span class="status-label">Homing Rockets</span>
                    <div class="status-fill" style="background-color: #ff9900;"></div>
                </div>
                <div id="status-mine" class="status-bar">
                    <span class="status-label">Plasma Mines</span>
                    <div class="status-fill" style="background-color: #cc00cc;"></div>
                </div>
            </div>
        </div>
        
        <!-- Comms Panel -->
        <div id="comms-panel">
            <div id="comms-title">Incoming Transmission</div>
            <div id="comms-text">...Decoding Subspace Signal...</div>
        </div>
        
        <div id="action-container">
            <!-- Upgrade Button (Bottom Left) -->
            <div id="upgrade-container">
                <div id="upgrade-btn-bottom">OPEN<br>SHOP</div>
                <div id="upgrade-label">Fabricator</div>
            </div>
            
            <!-- Ultimate Button -->
            <div id="ultimate-container">
                <div id="ultimate-btn">CHARGING</div>
                <div id="ultimate-label">Nova Bomb</div>
            </div>
        </div>
        
        <!-- Boss HUD -->
        <div id="boss-hud">
            <div id="boss-name">Warning: Boss Approaching</div>
            <div id="boss-health-bar">
                <div id="boss-health-fill"></div>
            </div>
        </div>
        
        <div class="lcars-bar"></div>
    </div>
    
    <div id="pause-screen">
        <div id="pause-text">SIMULATION PAUSED</div>
        <button id="resume-btn" class="btn">RESUME</button>
        <button id="mute-btn-pause" class="btn btn-secondary" style="margin-top: 20px;">Toggle Sound</button>
    </div>
    
    <!-- Instructions Screen -->
    <div id="instructions-screen">
        <div id="instructions-title">Mission Briefing</div>
        <div class="instructions-content">
            <ul>
                <li><strong>CONTROLS:</strong> Touch & Drag anywhere on screen to steer. Movement is relative to your finger.</li>
                <li><strong>COMBAT:</strong> Your ship auto-fires. Dodge enemy fire and collect power-ups from fallen ships.</li>
                <li><strong>CREDITS:</strong> Collect golden bars to buy upgrades in the FABRICATOR.</li>
                <li><strong>NOVA BOMB:</strong> When the bar is full, press the button for a screen-clearing blast.</li>
                <li><strong>OBJECTIVE:</strong> Survive the waves, defeat the Galactic Bosses, and secure the sector.</li>
                <li><strong>BONUS:</strong> Survive long enough to unlock the <strong>SIGMA 13</strong> protocol.</li>
            </ul>
        </div>
        <button id="close-instructions-btn" class="btn">UNDERSTOOD</button>
    </div>
    
    <!-- Database Screen -->
    <div id="database-screen">
        <div id="database-title">Enemy Database</div>
        <div class="database-grid" id="database-grid">
            <!-- Items populated by JS -->
        </div>
        <button id="close-database-btn" class="btn">CLOSE DATABASE</button>
    </div>
    
    <!-- Upgrade Screen -->
    <div id="upgrade-screen">
        <div id="upgrade-title">Ship Fabricator</div>
        <div id="current-latinum">Credits: 0</div>
        <div class="upgrade-grid">
            <div class="upgrade-card">
                <div class="upgrade-name">Hull Repair</div>
                <div class="upgrade-cost">Cost: 50</div>
                <div style="color:#ccc; font-size:12px; margin-bottom:5px;">Restores 50 HP</div>
                <button class="upgrade-buy-btn" onclick="buyUpgrade('repair', 50)">FABRICATE</button>
            </div>
            <div class="upgrade-card">
                <div class="upgrade-name">Shield Harmonics</div>
                <div class="upgrade-cost">Cost: 100</div>
                <div style="color:#ccc; font-size:12px; margin-bottom:5px;">+20 Max Shields</div>
                <button class="upgrade-buy-btn" onclick="buyUpgrade('maxhp', 100)">FABRICATE</button>
            </div>
            <div class="upgrade-card">
                <div class="upgrade-name">Laser Power</div>
                <div class="upgrade-cost">Cost: 200</div>
                <div style="color:#ccc; font-size:12px; margin-bottom:5px;">+1 Damage/Shot</div>
                <button class="upgrade-buy-btn" onclick="buyUpgrade('damage', 200)">FABRICATE</button>
            </div>
            <div class="upgrade-card">
                <div class="upgrade-name">Cooling Coils</div>
                <div class="upgrade-cost">Cost: 150</div>
                <div style="color:#ccc; font-size:12px; margin-bottom:5px;">+10% Fire Rate</div>
                <button class="upgrade-buy-btn" onclick="buyUpgrade('firerate', 150)">FABRICATE</button>
            </div>
        </div>
        <button id="close-upgrade-btn" class="btn">RETURN TO BATTLE</button>
    </div>

    <div id="start-screen">
        <h1>Cosmic Vanguard</h1>
        <p>Command the Vanguard Starship.</p>
        <button class="btn" id="start-btn">Engage</button>
        <div style="display:flex; gap:15px; margin-top:15px;">
            <button class="btn btn-secondary" id="instructions-btn">Instructions</button>
            <button class="btn btn-tertiary" id="database-btn">Database</button>
        </div>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1 id="game-over-title">System Critical</h1>
        
        <!-- Continue Section -->
        <div id="continue-section">
            <p style="color: #ccc; font-size: 18px;">Systems Failing...</p>
            <div id="continue-timer">15</div>
            <button class="btn" id="continue-btn">EMERGENCY RESTART</button>
            <p style="color: #888; margin-top: 10px; font-size: 14px;">Lives Remaining: <span id="lives-display" style="color: #ffcc00; font-weight:bold;">3</span></p>
        </div>

        <!-- Final Game Over Section -->
        <div id="final-options" class="hidden">
            <p id="final-score">Score: 0</p>
            <p id="best-score" style="color: #888; margin-top: 5px;">High Score: 0</p>
            <p id="new-highscore-msg" style="color: #ffcc00; font-weight: bold; display: none;">NEW HIGH SCORE!</p>
            <button class="btn" id="restart-btn">Re-Initialize</button>
            <button class="btn btn-tertiary" id="home-btn" style="margin-top: 15px;">Return to Base</button>
        </div>
    </div>

    <script>
        // --- Gemini API Config ---
        const apiKey = ""; // Provided by environment at runtime

        async function getGeminiTaunt(bossName) {
            if (!apiKey) {
                console.warn("API Key missing, skipping Gemini call.");
                showComms(bossName, "I will destroy you, Captain!"); // Fallback
                return;
            }

            const prompt = `You are the galactic villain ${bossName}. Give me a short, threatening, 1-sentence taunt to a Space Fleet Captain. Do not use quotes.`;
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }]
                    })
                });

                const data = await response.json();
                const text = data.candidates?.[0]?.content?.parts?.[0]?.text || "Your destruction is imminent.";
                showComms(bossName, text);
            } catch (error) {
                console.error("Gemini Error:", error);
                showComms(bossName, "Communications disrupted...");
            }
        }

        function showComms(sender, message) {
            const panel = document.getElementById('comms-panel');
            const title = document.getElementById('comms-title');
            const text = document.getElementById('comms-text');
            
            title.innerText = `INCOMING SIGNAL: ${sender}`;
            text.innerText = message;
            panel.style.display = 'flex';
            panel.style.opacity = '0';
            
            // Fade in
            requestAnimationFrame(() => {
                panel.style.opacity = '1';
            });
            
            // Hide after 5 seconds
            setTimeout(() => {
                panel.style.opacity = '0';
                setTimeout(() => panel.style.display = 'none', 500);
            }, 5000);
        }

        // --- Audio System (Synthesizer) ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;
        let isMuted = false;

        const SoundManager = {
            init: () => {
                if (!audioCtx) {
                    audioCtx = new AudioContext();
                } else if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
            },
            
            toggleMute: () => {
                isMuted = !isMuted;
                const txt = isMuted ? "SND: OFF" : "SND: ON";
                document.getElementById('mute-btn').innerText = txt;
                return isMuted;
            },
            
            playTone: (freq, type, duration, vol = 0.1) => {
                if (isMuted || !audioCtx) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            },

            shoot: () => {
                if (isMuted || !audioCtx) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.15);
                gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.15);
            },

            enemyShoot: () => {
                if (isMuted || !audioCtx) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(300, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(100, audioCtx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.03, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.2);
            },

            explode: (large = false) => {
                if (isMuted || !audioCtx) return;
                const bufferSize = audioCtx.sampleRate * (large ? 1.0 : 0.3);
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 1000;
                gain.gain.setValueAtTime(large ? 0.3 : 0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + (large ? 1.0 : 0.3));
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                noise.start();
            },
            
            powerup: () => {
                if (isMuted || !audioCtx) return;
                const now = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(660, now);
                osc.frequency.setValueAtTime(880, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 0.3);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(now + 0.3);
            },
            
            coin: () => {
                if (isMuted || !audioCtx) return;
                const now = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(1200, now);
                osc.frequency.setValueAtTime(1800, now + 0.05);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 0.1);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(now + 0.1);
            },
            
            bossAlarm: () => {
                 if (isMuted || !audioCtx) return;
                 const now = audioCtx.currentTime;
                 const osc = audioCtx.createOscillator();
                 const gain = audioCtx.createGain();
                 osc.type = 'triangle';
                 osc.frequency.setValueAtTime(400, now);
                 osc.frequency.linearRampToValueAtTime(800, now + 0.5);
                 osc.frequency.linearRampToValueAtTime(400, now + 1.0);
                 gain.gain.setValueAtTime(0.2, now);
                 gain.gain.linearRampToValueAtTime(0.01, now + 1.0);
                 osc.connect(gain);
                 gain.connect(audioCtx.destination);
                 osc.start();
                 osc.stop(now + 1.0);
            },
            
            ultimate: () => {
                 if (isMuted || !audioCtx) return;
                 const now = audioCtx.currentTime;
                 const osc = audioCtx.createOscillator();
                 const gain = audioCtx.createGain();
                 osc.type = 'sawtooth';
                 osc.frequency.setValueAtTime(100, now);
                 osc.frequency.exponentialRampToValueAtTime(800, now + 0.5);
                 osc.frequency.exponentialRampToValueAtTime(50, now + 1.5);
                 gain.gain.setValueAtTime(0.3, now);
                 gain.gain.linearRampToValueAtTime(0.01, now + 1.5);
                 osc.connect(gain);
                 gain.connect(audioCtx.destination);
                 osc.start();
                 osc.stop(now + 1.5);
            },
            
            buy: () => {
                if (isMuted || !audioCtx) return;
                const now = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.setValueAtTime(600, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 0.3);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(now + 0.3);
            }
        };
        
        // Mute Toggle Logic
        const muteHandler = () => SoundManager.toggleMute();
        document.getElementById('mute-btn').addEventListener('click', muteHandler);
        document.getElementById('mute-btn-pause').addEventListener('click', muteHandler);


        // --- Game Configuration & State ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let gameState = 'START'; 
        let score = 0;
        
        let highScore = localStorage.getItem('trek1942_highscore') || 0;
        document.getElementById('highscore-display').innerText = `High: ${highScore}`;

        let frameCount = 0;
        let difficultyMultiplier = 1;
        
        // Spawn Delay (for quiet time after boss)
        let spawnDelay = 0;

        // Continue System State
        let livesRemaining = 3;
        let continueInterval = null;
        
        // Screen Shake State
        let shakeDuration = 0;
        let shakeMagnitude = 0;
        
        // Ultimate Flash State
        let flashDuration = 0;

        // Boss State
        let bossActive = false;
        let currentBoss = null;
        let nextBossScore = 1000;
        let bossIndex = 0;
        // New non-infringing names (Added General Zarris for Bonus Level)
        const bossList = ["General Kael", "Void Lord", "Cyber Matriarch", "Cosmic Entity", "Void Empress", "General Zarris"];

        // Entity Arrays
        let player;
        let enemies = [];
        let bullets = [];
        let upgrades = [];
        let coins = []; 
        let particles = [];
        let stars = [];
        let planets = []; 
        let mines = [];
        let rockets = [];
        let floatingTexts = []; 

        // Input State
        const input = {
            x: 0,
            y: 0,
            isTouching: false
        };
        
        // Relative Touch State
        let dragStartX = 0;
        let dragStartY = 0;
        let playerStartX = 0;
        let playerStartY = 0;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (player) {
                player.x = Math.min(Math.max(player.x, player.width/2), canvas.width - player.width/2);
                player.y = Math.min(Math.max(player.y, player.height/2), canvas.height - player.height/2);
                player.targetX = player.x;
                player.targetY = player.y;
            }
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Input Listeners ---
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState !== 'PLAYING') return;
            input.isTouching = true;
            dragStartX = e.touches[0].clientX;
            dragStartY = e.touches[0].clientY;
            playerStartX = player.targetX; 
            playerStartY = player.targetY;
        }, {passive: false});

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (gameState !== 'PLAYING') return;
            const currentX = e.touches[0].clientX;
            const currentY = e.touches[0].clientY;
            const dx = currentX - dragStartX;
            const dy = currentY - dragStartY;
            player.setTarget(playerStartX + dx, playerStartY + dy);
        }, {passive: false});

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            input.isTouching = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (gameState !== 'PLAYING') return;
            if (!input.isTouching) {
                player.setTarget(e.clientX, e.clientY);
            }
        });

        canvas.addEventListener('mousedown', () => input.isTouching = true);
        canvas.addEventListener('mouseup', () => input.isTouching = false);
        
        // --- Pause Logic ---
        const pauseBtn = document.getElementById('pause-btn');
        const resumeBtn = document.getElementById('resume-btn');
        const pauseScreen = document.getElementById('pause-screen');
        
        pauseBtn.addEventListener('click', () => {
            if (gameState === 'PLAYING') {
                gameState = 'PAUSED';
                pauseScreen.style.display = 'flex';
                if(audioCtx && audioCtx.state === 'running') audioCtx.suspend();
            }
        });
        
        resumeBtn.addEventListener('click', () => {
            if (gameState === 'PAUSED') {
                gameState = 'PLAYING';
                pauseScreen.style.display = 'none';
                if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
            }
        });
        
        // --- Instructions Logic ---
        const instructionsBtn = document.getElementById('instructions-btn');
        const closeInstructionsBtn = document.getElementById('close-instructions-btn');
        const instructionsScreen = document.getElementById('instructions-screen');
        
        instructionsBtn.addEventListener('click', () => {
            instructionsScreen.style.display = 'flex';
        });
        
        closeInstructionsBtn.addEventListener('click', () => {
            instructionsScreen.style.display = 'none';
        });
        
        // --- Database Logic ---
        const databaseBtn = document.getElementById('database-btn');
        const closeDatabaseBtn = document.getElementById('close-database-btn');
        const databaseScreen = document.getElementById('database-screen');
        const databaseGrid = document.getElementById('database-grid');
        
        const enemyData = [
            {type: 'scout', name: 'Scout', desc: 'Light reconnaissance vessel. Fast but fragile.', hp: 2, score: 10},
            {type: 'cruiser', name: 'Cruiser', desc: 'Heavily armored assault ship. Fires dual blasts.', hp: 5, score: 50},
            {type: 'scarab', name: 'Void Stinger', desc: 'Swarm attacker. Agile and aggressive.', hp: 6, score: 60},
            {type: 'obsidian', name: 'Golden Enforcer', desc: 'Durable hull with disruptive weaponry.', hp: 10, score: 80},
            {type: 'bio', name: 'Organic Terror', desc: 'Erratic movement and self-healing hull.', hp: 12, score: 120},
            {type: 'cube', name: 'Cyber Fortress', desc: 'Massive durability. Absorbs heavy fire.', hp: 24, score: 150},
            {type: 'zarris_fighter', name: 'Zarris Drone', desc: 'Asymmetrical fighter from the Gamma Quadrant.', hp: 8, score: 90},
            {type: 'void_mine', name: 'Void Mine', desc: 'Stationary magnetic hazard.', hp: 15, score: 30}
        ];
        
        const bossData = [
            {name: 'General Kael', desc: 'Fleet Commander. Fires tactical bursts.', hp: 250, score: 1000},
            {name: 'Void Lord', desc: 'Wields the power of the singularity.', hp: 400, score: 2000},
            {name: 'Cyber Matriarch', desc: 'Assimilates technology. High regeneration.', hp: 600, score: 3000},
            {name: 'Cosmic Entity', desc: 'Pure energy being. Shifts reality.', hp: 900, score: 5000},
            {name: 'Void Empress', desc: 'The end of all things. Beware.', hp: 1200, score: 6000},
            {name: 'General Zarris', desc: 'Tyrant of the Fatu-Krey. Armed with Omega weapons.', hp: 2000, score: 10000}
        ];
        
        function generateDatabase() {
            databaseGrid.innerHTML = ''; // Clear
            
            // Render Enemies
            enemyData.forEach(data => {
                const card = document.createElement('div');
                card.className = 'enemy-card';
                
                const cvs = document.createElement('canvas');
                cvs.width = 100; cvs.height = 80;
                const c = cvs.getContext('2d');
                
                // Create dummy enemy to draw
                const dummy = new Enemy(data.type, 50, 40); 
                dummy.draw(c); // Pass the mini-context
                
                card.innerHTML = `
                    ${cvs.outerHTML}
                    <div class="enemy-name">${data.name}</div>
                    <div class="enemy-desc">${data.desc}</div>
                    <div class="enemy-stats">HP: ${data.hp} | SCORE: ${data.score}</div>
                `;
                
                // Need to redraw canvas after inserting innerHTML because simple append copies HTML string not live canvas state?
                // Actually innerHTML serialization of canvas is empty. 
                // Better to append elements.
                databaseGrid.appendChild(card);
                // Re-get canvas to draw
                const finalCvs = card.querySelector('canvas');
                const finalC = finalCvs.getContext('2d');
                dummy.draw(finalC);
            });
            
            // Render Bosses
            bossData.forEach(data => {
                const card = document.createElement('div');
                card.className = 'enemy-card';
                card.style.borderColor = '#ff3300'; // Boss styling
                
                const cvs = document.createElement('canvas');
                cvs.width = 120; cvs.height = 100;
                const c = cvs.getContext('2d');
                
                const dummy = new Boss(data.name);
                dummy.x = 60; dummy.y = 50; // Center
                dummy.draw(c);
                
                card.innerHTML = `
                    <div style="width:120px; height:100px;"></div>
                    <div class="enemy-name" style="color:#ff3300">${data.name}</div>
                    <div class="enemy-desc">${data.desc}</div>
                    <div class="enemy-stats" style="color:#ff9900">HP: ${data.hp} | SCORE: ${data.score}</div>
                `;
                
                databaseGrid.appendChild(card);
                const placeholder = card.children[0];
                placeholder.replaceWith(cvs);
                
                // Re-draw
                const finalC = cvs.getContext('2d');
                dummy.draw(finalC);
            });
        }
        
        databaseBtn.addEventListener('click', () => {
            generateDatabase();
            databaseScreen.style.display = 'flex';
        });
        
        closeDatabaseBtn.addEventListener('click', () => {
            databaseScreen.style.display = 'none';
        });
        
        // --- Upgrade UI Logic ---
        const upgradeBtnBottom = document.getElementById('upgrade-btn-bottom'); 
        const upgradeScreen = document.getElementById('upgrade-screen');
        const closeUpgradeBtn = document.getElementById('close-upgrade-btn');
        
        upgradeBtnBottom.addEventListener('click', (e) => {
            e.stopPropagation(); 
            if (gameState === 'PLAYING') {
                gameState = 'PAUSED'; 
                upgradeScreen.style.display = 'flex';
                updateUpgradeUI();
                if(audioCtx && audioCtx.state === 'running') audioCtx.suspend();
            }
        });
        
        closeUpgradeBtn.addEventListener('click', () => {
            if (gameState === 'PAUSED') {
                gameState = 'PLAYING';
                upgradeScreen.style.display = 'none';
                if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
            }
        });
        
        // Global function for HTML buttons
        window.buyUpgrade = function(type, cost) {
            if(player.coins >= cost) {
                player.coins -= cost;
                SoundManager.buy();
                
                if(type === 'repair') {
                    player.hp = Math.min(player.maxHp, player.hp + 50);
                    updateHealth();
                }
                else if(type === 'maxhp') {
                    player.maxHp += 20;
                    player.hp += 20; 
                    updateHealth();
                }
                else if(type === 'damage') {
                    player.damage += 1;
                }
                else if(type === 'firerate') {
                    player.fireRateModifier *= 0.9; 
                }
                
                updateUpgradeUI();
                document.getElementById('latinum-display').innerText = `Credits: ${player.coins}`;
            }
        }
        
        function updateUpgradeUI() {
            document.getElementById('current-latinum').innerText = `Credits: ${player.coins}`;
            const btns = document.querySelectorAll('.upgrade-buy-btn');
            btns.forEach(btn => {
                const cost = parseInt(btn.getAttribute('onclick').split(',')[1]);
                btn.disabled = player.coins < cost;
            });
        }
        
        // --- Ultimate Trigger ---
        const ultBtn = document.getElementById('ultimate-btn');
        ultBtn.addEventListener('click', (e) => {
            e.stopPropagation(); 
            if(gameState === 'PLAYING' && player && player.ultimateCharge >= player.maxUltimate) {
                triggerUltimate();
            }
        });

        function triggerShake(frames, mag) {
            shakeDuration = frames;
            shakeMagnitude = mag;
        }

        function triggerUltimate() {
            player.ultimateCharge = 0;
            updateUltimateUI();
            SoundManager.ultimate();
            triggerShake(20, 10);
            flashDuration = 20; 
            
            bullets = bullets.filter(b => !b.isEnemy);
            
            enemies.forEach(e => {
                if(e.active) {
                    e.takeDamage(50); 
                    if(!e.active) {
                        score += e.scoreVal;
                        spawnCoins(e.x, e.y, e.type === 'cube' ? 5 : 2); 
                        for(let i=0; i<8; i++) particles.push(new Particle(e.x, e.y, '#fff'));
                    }
                }
            });
            
            if(bossActive && currentBoss && currentBoss.active) {
                currentBoss.takeDamage(50);
                for(let i=0; i<15; i++) particles.push(new Particle(currentBoss.x, currentBoss.y, '#fff'));
                if(!currentBoss.active) handleBossDefeat();
            }
        }

        function updateUltimateUI() {
            if(!player) return;
            const pct = Math.floor((player.ultimateCharge / player.maxUltimate) * 100);
            if (player.ultimateCharge >= player.maxUltimate) {
                ultBtn.innerText = "FIRE";
                ultBtn.classList.add('ready');
                ultBtn.style.background = ""; 
            } else {
                ultBtn.innerText = pct + "%";
                ultBtn.classList.remove('ready');
                ultBtn.style.background = `rgba(30, 30, 30, 0.6)`;
            }
        }

        // --- Classes ---
        
        class FloatingText {
            constructor(x, y, text, color, size = 14) {
                this.x = x + (Math.random() * 20 - 10);
                this.y = y;
                this.text = text;
                this.color = color;
                this.size = size;
                this.life = 1.0; 
                this.vy = 1.5; 
            }

            update() {
                this.y -= this.vy;
                this.life -= 0.02; 
            }

            draw() {
                ctx.save();
                
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.font = `bold ${this.size}px Arial`;
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.strokeText(this.text, this.x, this.y);
                ctx.fillText(this.text, this.x, this.y);
                
                ctx.restore();
            }
        }
        
        class Coin {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 15;
                this.height = 15;
                this.vy = 3; 
                this.vx = (Math.random() - 0.5) * 2;
                this.active = true;
                this.frame = 0;
            }
            
            update() {
                this.y += this.vy;
                this.x += this.vx;
                this.frame++;
                
                const dist = Math.hypot(player.x - this.x, player.y - this.y);
                if(dist < 100) {
                    this.x += (player.x - this.x) * 0.1;
                    this.y += (player.y - this.y) * 0.1;
                }
                
                if (this.y > canvas.height + 20) this.active = false;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Spin effect
                const scaleX = Math.cos(this.frame * 0.1);
                ctx.scale(scaleX, 1);
                
                ctx.fillStyle = '#ffcc00';
                ctx.shadowBlur = 5;
                ctx.shadowColor = '#ffcc00';
                ctx.fillRect(-6, -4, 12, 8);
                ctx.strokeStyle = '#fff7cc';
                ctx.lineWidth = 1;
                ctx.strokeRect(-6, -4, 12, 8);
                ctx.restore();
            }
        }

        class Planet {
            constructor() {
                this.reset();
                this.y = Math.random() * canvas.height; 
            }

            reset() {
                this.radius = Math.random() * 40 + 20; 
                this.x = Math.random() * (canvas.width - this.radius*2) + this.radius;
                this.y = -this.radius * 2 - (Math.random() * 2000); 
                this.speed = Math.random() * 0.3 + 0.1; 
                
                const hues = [0, 200, 280, 30, 120]; 
                this.hue = hues[Math.floor(Math.random() * hues.length)];
                this.type = Math.random() > 0.5 ? 'gas' : 'terrestrial';
            }

            update() {
                this.y += this.speed * (gameState === 'PLAYING' ? 1 : 0.1);
                if (this.y > canvas.height + this.radius * 2) {
                     this.reset();
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                const grad = ctx.createRadialGradient(-this.radius*0.3, -this.radius*0.3, this.radius * 0.1, 0, 0, this.radius);
                grad.addColorStop(0, `hsla(${this.hue}, 80%, 70%, 0.3)`);
                grad.addColorStop(0.5, `hsla(${this.hue}, 60%, 50%, 0.3)`);
                grad.addColorStop(1, `hsla(${this.hue}, 60%, 20%, 0.3)`);
                
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI*2);
                ctx.fill();
                
                if (this.type === 'gas') {
                    ctx.strokeStyle = `hsla(${this.hue}, 40%, 80%, 0.1)`;
                    ctx.lineWidth = 6;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.radius * 1.6, this.radius * 0.3, Math.PI / 8, 0, Math.PI*2);
                    ctx.stroke();
                }
                
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.beginPath();
                ctx.arc(5, 5, this.radius, 0, Math.PI*2);
                ctx.fill();
                
                ctx.restore();
            }
        }

        // IMPROVEMENT 1: Warp Speed Stars
        class Star {
            constructor() {
                this.reset();
                this.y = Math.random() * canvas.height;
            }

            reset() {
                this.x = Math.random() * canvas.width;
                this.y = -10;
                // z represents depth/speed. Higher Z = closer/faster
                this.z = Math.random() * 4 + 0.5; 
                this.size = Math.max(0.5, this.z * 0.5);
                this.opacity = Math.min(1, this.z * 0.2);
            }

            update() {
                // Speed based on Z index for parallax
                this.y += Math.pow(this.z, 2) * (gameState === 'PLAYING' ? 1 : 0.1); 
                if (this.y > canvas.height) this.reset();
            }

            draw() {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
                ctx.beginPath();
                // Draw as a streak based on speed
                const length = this.z * 5; 
                ctx.rect(this.x, this.y, this.size, length);
                ctx.fill();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                // Add friction and drag for better feel
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 4 + 1;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.decay = Math.random() * 0.03 + 0.02;
                this.size = Math.random() * 3 + 1;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.95; // Drag
                this.vy *= 0.95;
                this.life -= this.decay;
                this.size *= 0.95; // Shrink
            }

            draw() {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class Upgrade {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vy = 2;
                this.width = 30;
                this.height = 30;
                this.active = true;
                this.wobble = Math.random() * Math.PI * 2;
                
                // Small chance to spawn CHRONO (Sigma 13)
                if (Math.random() < 0.02) {
                    this.type = 'CHRONO';
                } else {
                    const r = Math.random();
                    if (r < 0.2) this.type = 'SHIELD';
                    else if (r < 0.4) this.type = 'WINGMAN';
                    else if (r < 0.6) this.type = 'RAPID';
                    else if (r < 0.8) this.type = 'ROCKET';
                    else this.type = 'MINE';
                }
            }

            update() {
                this.y += this.vy;
                this.wobble += 0.1;
                this.x += Math.sin(this.wobble) * 0.5; // Slight drift
                if (this.y > canvas.height + 50) this.active = false;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.shadowBlur = 10;
                
                if (this.type === 'CHRONO') {
                    // SIGMA 13 ART
                    ctx.shadowColor = '#00f';
                    let grad = ctx.createLinearGradient(-10, 0, 10, 0);
                    grad.addColorStop(0, '#00f');
                    grad.addColorStop(0.5, '#fff'); // Bright core
                    grad.addColorStop(1, '#00f');
                    ctx.fillStyle = grad;
                    ctx.fillRect(-10, -15, 20, 30);
                    
                    // Caps
                    ctx.fillStyle = '#555';
                    ctx.fillRect(-12, -18, 24, 5); 
                    ctx.fillRect(-12, 13, 24, 5);
                }
                else {
                    // STANDARD UPGRADES
                    let color = '#fff';
                    let label = '?';
                    
                    if (this.type === 'SHIELD') { color = '#00aaff'; label = 'S'; }
                    else if (this.type === 'WINGMAN') { color = '#ffcc00'; label = 'W'; }
                    else if (this.type === 'RAPID') { color = '#ff3300'; label = 'F'; }
                    else if (this.type === 'ROCKET') { color = '#ff9900'; label = 'R'; }
                    else if (this.type === 'MINE') { color = '#cc00cc'; label = 'M'; }
                    
                    ctx.fillStyle = color;
                    ctx.shadowColor = color;
                    ctx.beginPath();
                    ctx.arc(0, 0, 15, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Inner ring
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 10, 0, Math.PI*2);
                    ctx.stroke();

                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(label, 0, 1);
                }
                
                ctx.restore();
            }
        }

        class Mine {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 20;
                this.height = 20;
                this.active = true;
                this.blink = 0;
            }

            update() {
                this.y -= 3; 
                this.blink++;
                if (this.y < -50) this.active = false;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.fillStyle = (Math.floor(this.blink / 10) % 2 === 0) ? '#cc00cc' : '#ff00ff';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#cc00cc';
                
                ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                    let angle = (i / 8) * Math.PI * 2;
                    ctx.lineTo(Math.cos(angle) * 10, Math.sin(angle) * 10);
                    ctx.lineTo(Math.cos(angle + 0.4) * 5, Math.sin(angle + 0.4) * 5);
                }
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
        }

        class Rocket {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 10;
                this.height = 20;
                this.active = true;
                this.target = null;
                this.speed = 8;
                this.angle = -Math.PI / 2;
            }

            update() {
                if (!this.target || !this.target.active) {
                    let closest = null;
                    let minDist = Infinity;
                    
                    if (bossActive && currentBoss) {
                        this.target = currentBoss;
                    } else {
                        enemies.forEach(e => {
                            if (!e.active) return;
                            const dist = Math.hypot(e.x - this.x, e.y - this.y);
                            if (dist < minDist) {
                                minDist = dist;
                                closest = e;
                            }
                        });
                        this.target = closest;
                    }
                }

                if (this.target) {
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const targetAngle = Math.atan2(dy, dx);
                    
                    let diff = targetAngle - this.angle;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    this.angle += diff * 0.1;
                }

                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                
                if (Math.random() < 0.5) {
                    particles.push(new Particle(this.x, this.y, '#ff9900'));
                }

                if (this.y < -50 || this.y > canvas.height + 50 || this.x < -50 || this.x > canvas.width + 50) {
                    this.active = false;
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle + Math.PI/2); 
                
                ctx.fillStyle = '#fff';
                ctx.fillRect(-3, -10, 6, 15);
                ctx.fillStyle = '#ff9900';
                ctx.fillRect(-3, 5, 6, 5); 
                
                ctx.restore();
            }
        }

        class Bullet {
            constructor(x, y, isEnemy, vx = 0, vy = 0, color = null, size = 4) {
                this.x = x;
                this.y = y;
                this.isEnemy = isEnemy;
                this.width = size;
                this.height = size * 3; 
                
                if (vx === 0 && vy === 0) {
                    this.vx = 0;
                    this.vy = isEnemy ? 7 : -12;
                    this.height = 15; 
                    this.width = 4;
                } else {
                    this.vx = vx;
                    this.vy = vy;
                    if (size > 5) this.height = size; 
                }

                this.active = true;
                this.color = color; 
                this.isOrb = (Math.abs(this.width - this.height) < 2); 
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                
                if (this.y < -50 || this.y > canvas.height + 50 || this.x < -50 || this.x > canvas.width + 50) {
                    this.active = false;
                }
            }

            draw() {
                ctx.save();
                
                if (this.isOrb || this.width > 6) {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = this.color || '#d0f';
                    ctx.fillStyle = this.color || '#fff';
                    
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.width/2, 0, Math.PI*2);
                    ctx.fill();
                } 
                else {
                    if (this.color) {
                         ctx.fillStyle = this.color;
                         ctx.shadowBlur = 5;
                         ctx.shadowColor = this.color;
                    } else if (this.isEnemy) {
                        ctx.fillStyle = '#00ff00';
                        ctx.shadowBlur = 5;
                        ctx.shadowColor = '#00ff00';
                    } else {
                        ctx.fillStyle = '#ffaa00';
                        ctx.shadowBlur = 5;
                        ctx.shadowColor = '#ffaa00';
                    }
                    ctx.fillRect(this.x - this.width/2, this.y, this.width, this.height);
                }
                ctx.restore();
            }
        }

        class Ship {
            constructor(x, y, hp) {
                this.x = x;
                this.y = y;
                this.hp = hp;
                this.maxHp = hp;
                this.width = 40;
                this.height = 40;
                this.active = true;
                this.flashTimer = 0;
                this.shieldHitTimer = 0; // New: For shield ripple effect
                this.invincible = false; // New: For respawn
            }

            takeDamage(amount) {
                if (this.invincible) return; // Ignore damage if invincible

                // SIGMA 13 CHECK
                if (this.isPlayer && this.hasSigma13 && (this.hp - amount <= 0)) {
                    this.hp = this.maxHp;
                    this.hasSigma13 = false;
                    this.invincible = true;
                    setTimeout(() => { if(this) this.invincible = false; }, 3000);
                    
                    // Clear screen
                    bullets = [];
                    enemies.forEach(e => e.takeDamage(1000));
                    
                    showComms("SIGMA 13", "TIMELINE RESTORED.");
                    // Flash blue
                    flashDuration = 10;
                    // Override default logic
                    return;
                }

                this.hp -= amount;
                this.flashTimer = 5;
                if(this.isPlayer) this.shieldHitTimer = 10; // Trigger shield ripple
                
                let color = '#fff';
                let size = 14;
                
                if (this.isPlayer) {
                    color = '#ff3333'; 
                    size = 16;
                } else if (amount > 5) {
                    color = '#ffcc00'; 
                    size = 20;
                }
                
                if (gameState === 'PLAYING') {
                    floatingTexts.push(new FloatingText(this.x, this.y - 20, "-" + Math.floor(amount), color, size));
                }
                
                if (this.hp <= 0) {
                    this.explode();
                    this.active = false;
                }
            }

            explode() {
                for(let i=0; i<15; i++) {
                    particles.push(new Particle(this.x, this.y, this.isPlayer ? '#00aaff' : '#ffaa00'));
                }
            }
        }

        class Player extends Ship {
            constructor() {
                super(canvas.width / 2, canvas.height - 100, 100);
                this.isPlayer = true;
                this.width = 60;
                this.height = 70;
                this.lastShot = 0;
                this.fireRate = 28; // Difficulty Adjustment: Slightly slower (was 25)
                
                this.coins = 0;
                this.damage = 1; 
                this.fireRateModifier = 1.0; 
                
                this.wingmanTimer = 0;
                this.rapidTimer = 0;
                this.rocketTimer = 0;
                this.mineTimer = 0;
                this.maxTimer = 600;
                
                this.ultimateCharge = 0;
                this.maxUltimate = 100;
                
                // Bonus Level Transformation State
                this.isProtector = false; 
                this.hasSigma13 = false;
            }

            setTarget(tx, ty) {
                this.targetX = tx;
                this.targetY = ty;
            }

            activateUpgrade(type) {
                if (type === 'CHRONO') {
                    this.hasSigma13 = true;
                    showComms("ACQUIRED", "SIGMA 13 DEVICE INSTALLED.");
                }
                else if (type === 'SHIELD') {
                    this.hp = Math.min(this.maxHp, this.hp + 50);
                    updateHealth();
                } 
                else if (type === 'WINGMAN') this.wingmanTimer += this.maxTimer; 
                else if (type === 'RAPID') this.rapidTimer += this.maxTimer; 
                else if (type === 'ROCKET') this.rocketTimer += this.maxTimer; 
                else if (type === 'MINE') this.mineTimer += this.maxTimer; 
                
                updateTimersUI();
            }

            update() {
                if (this.targetX !== undefined) {
                    this.x += (this.targetX - this.x) * 0.15;
                    this.y += (this.targetY - this.y) * 0.15;
                }

                this.x = Math.max(this.width/2, Math.min(canvas.width - this.width/2, this.x));
                this.y = Math.max(this.height/2, Math.min(canvas.height - this.height/2, this.y));

                // Ultimate Charge
                if (this.ultimateCharge < this.maxUltimate) {
                    this.ultimateCharge += 0.04; 
                    if (this.ultimateCharge >= this.maxUltimate) {
                        this.ultimateCharge = this.maxUltimate;
                        updateUltimateUI(); 
                    } else if (frameCount % 30 === 0) {
                        updateUltimateUI();
                    }
                }

                const prog = Math.min(bossIndex, 5);
                const currentBaseRate = (30 - (prog * 3)) * this.fireRateModifier;
                const currentRapidRate = (16 - (prog * 1.6)) * this.fireRateModifier;

                if (this.rapidTimer > 0) {
                    this.rapidTimer--;
                    this.fireRate = currentRapidRate;
                } else {
                    this.fireRate = currentBaseRate;
                }
                
                if (this.wingmanTimer > 0) this.wingmanTimer--;
                if (this.rocketTimer > 0) this.rocketTimer--;
                if (this.mineTimer > 0) this.mineTimer--;

                if (frameCount - this.lastShot > this.fireRate) {
                    this.shoot();
                    this.lastShot = frameCount;
                }
                
                const rocketRate = 60 - (prog * 6);
                if (this.rocketTimer > 0 && frameCount % Math.floor(rocketRate) === 0) {
                    rockets.push(new Rocket(this.x, this.y));
                }
                
                const mineRate = 90 - (prog * 9);
                if (this.mineTimer > 0 && frameCount % Math.floor(mineRate) === 0) {
                    mines.push(new Mine(this.x, this.y - 30));
                }
                
                // Engine Trails
                if (frameCount % 3 === 0) {
                    particles.push(new Particle(this.x - 20, this.y + 30, '#00d4ff'));
                    particles.push(new Particle(this.x + 20, this.y + 30, '#00d4ff'));
                }

                if (this.flashTimer > 0) this.flashTimer--;
                if (this.shieldHitTimer > 0) this.shieldHitTimer--;
                
                // Handle Invincibility Visuals (Blinking)
                if (this.invincible) {
                    if (frameCount % 10 < 5) this.flashTimer = 2;
                }

                if (frameCount % 5 === 0) updateTimersUI();
            }

            shoot() {
                SoundManager.shoot(); 
                bullets.push(new Bullet(this.x - 15, this.y - 20, false));
                bullets.push(new Bullet(this.x + 15, this.y - 20, false));
                
                if (this.wingmanTimer > 0) {
                    bullets.push(new Bullet(this.x - 50, this.y, false));
                    bullets.push(new Bullet(this.x + 50, this.y, false));
                }
            }

            drawWingman(offsetX) {
                ctx.save();
                ctx.translate(offsetX, 10);
                ctx.scale(0.6, 0.6);
                ctx.fillStyle = '#ddd';
                ctx.beginPath();
                ctx.moveTo(0, -30);
                ctx.lineTo(15, 10);
                ctx.lineTo(10, 20);
                ctx.lineTo(-10, 20);
                ctx.lineTo(-15, 10);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = '#0099ff';
                ctx.fillRect(-12, 10, 4, 10);
                ctx.fillRect(8, 10, 4, 10);
                ctx.restore();
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                // IMPROVEMENT 3: Shield Ripple Effect
                if (this.shieldHitTimer > 0) {
                    ctx.beginPath();
                    ctx.strokeStyle = `rgba(0, 212, 255, ${this.shieldHitTimer / 10})`;
                    ctx.lineWidth = 3;
                    ctx.arc(0, 0, 50 + (10 - this.shieldHitTimer) * 2, 0, Math.PI*2);
                    ctx.stroke();
                    ctx.fillStyle = `rgba(0, 212, 255, ${this.shieldHitTimer / 20})`;
                    ctx.fill();
                }

                if (this.flashTimer > 0) ctx.globalCompositeOperation = 'source-atop'; 

                // --- DRAW PLAYER SHIP ---
                if (this.isProtector) {
                    // NSEA PROTECTOR (Galaxy Quest Ship)
                    let scale = 1.0; 

                    // 1. Rear Ion Thrusters (The long blue exhaust)
                    ctx.shadowBlur = 15; ctx.shadowColor = '#0af';
                    ctx.fillStyle = '#0af'; // Bright Blue Ion
                    ctx.fillRect(-22, 40, 6, 15);
                    ctx.fillRect(16, 40, 6, 15);
                    ctx.shadowBlur = 0; // Reset

                    // 2. Main Fuselage (Model-Kit Grey)
                    ctx.fillStyle = '#e0e0e0'; 
                    ctx.beginPath();
                    ctx.moveTo(0, -40); // Long Nose
                    ctx.lineTo(10, -10);
                    ctx.lineTo(12, 40); // Body width
                    ctx.lineTo(-12, 40);
                    ctx.lineTo(-10, -10);
                    ctx.closePath();
                    ctx.fill();

                    // 3. The "Galaxy Quest" Blue Stripe
                    ctx.fillStyle = '#0044aa';
                    ctx.fillRect(-5, -25, 10, 60);

                    // 4. Command Deck (Detachable Module)
                    ctx.fillStyle = '#f0f0f0';
                    ctx.beginPath();
                    ctx.arc(0, -15, 14, 0, Math.PI*2);
                    ctx.fill();
                    // Bridge Window
                    ctx.fillStyle = '#8ce';
                    ctx.beginPath();
                    ctx.arc(0, -18, 5, 0, Math.PI*2);
                    ctx.fill();

                    // 5. Swept Wings (Forward Swept)
                    ctx.fillStyle = '#d0d0d0';
                    ctx.beginPath();
                    ctx.moveTo(-12, 10);
                    ctx.lineTo(-40, 35); // Left Wing tip
                    ctx.lineTo(-12, 40);
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.moveTo(12, 10);
                    ctx.lineTo(40, 35); // Right Wing tip
                    ctx.lineTo(12, 40);
                    ctx.fill();
                } 
                else {
                    // STANDARD VANGUARD SHIP
                    // Ship Hull
                    ctx.fillStyle = '#ddd';
                    ctx.beginPath();
                    ctx.ellipse(0, -15, 30, 15, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ccc';
                    ctx.fillRect(-5, 0, 10, 35);
                    ctx.fillStyle = '#eee';
                    ctx.fillRect(-25, 10, 8, 30);
                    ctx.fillRect(17, 10, 8, 30);
                    ctx.fillStyle = '#0099ff';
                    ctx.fillRect(-24, 35, 6, 4);
                    ctx.fillRect(18, 35, 6, 4);
                    ctx.fillStyle = '#ff3300';
                    ctx.beginPath();
                    ctx.arc(0, 5, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                if (this.flashTimer > 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.beginPath();
                    ctx.arc(0, 0, 40, 0, Math.PI*2);
                    ctx.fill();
                }
                
                if (this.wingmanTimer > 0) {
                    this.drawWingman(-50);
                    this.drawWingman(50);
                }

                ctx.restore();
            }
        }

        class Enemy extends Ship {
            constructor(type, startX = null, startY = null) {
                // Use provided start coords or random
                super(startX || Math.random() * (canvas.width - 40) + 20, startY || -50, 1);
                this.type = type; 
                
                this.vy = Math.random() * 1.5 + 1 + (difficultyMultiplier * 0.3);
                this.vx = Math.sin(this.y * 0.01) * 2; 
                this.swing = Math.random() * 0.05;
                
                // DIFFICULTY ADJUSTMENT: HP INCREASED SIGNIFICANTLY
                if (type === 'cube') { // Tier 5 Tank (Borg Cube)
                    this.hp = 12 * difficultyMultiplier; // Increased to 12
                    this.width = 80;
                    this.height = 80;
                    this.scoreVal = 150;
                    this.vy = 0.5 + (difficultyMultiplier * 0.1);
                } else if (type === 'bio') { // Tier 4 Erratic (Species 8472)
                    this.hp = 6 * difficultyMultiplier; // Increased to 6
                    this.width = 40;
                    this.height = 55;
                    this.scoreVal = 120;
                    this.vy = 3 + (difficultyMultiplier * 0.5); 
                    this.swing = 0.2; 
                } else if (type === 'obsidian') { // Tier 2 Tank (Cardassian)
                    this.hp = 5 * difficultyMultiplier; // Increased to 5
                    this.width = 60;
                    this.height = 70;
                    this.scoreVal = 80;
                    this.vy = 1.2 + (difficultyMultiplier * 0.1); 
                } else if (type === 'scarab') { // Tier 3 Swarmer (Jem'Hadar)
                    this.hp = 3 * difficultyMultiplier; // Increased to 3
                    this.width = 35;
                    this.height = 40;
                    this.scoreVal = 60;
                    this.vy = 2.5 + (difficultyMultiplier * 0.2); 
                } else if (type === 'cruiser') { // Tier 1 Heavy (Romulan Warbird)
                    this.hp = 3 * difficultyMultiplier; // Increased to 3
                    this.width = 72;
                    this.height = 48;
                    this.scoreVal = 50;
                } else if (type === 'zarris_fighter') { // BONUS LEVEL ENEMY
                    this.hp = 8 * difficultyMultiplier; // Increased to 8
                    this.width = 50; this.height = 50;
                    this.scoreVal = 90;
                    this.vy = 2.5;
                } else if (type === 'void_mine') { // BONUS LEVEL HAZARD
                    this.hp = 15 * difficultyMultiplier; // Increased to 15
                    this.width = 40; this.height = 40;
                    this.scoreVal = 30;
                    this.vy = 1; // Slow drift
                } else { // Tier 1 Light (Klingon BoP)
                    this.hp = 2 * difficultyMultiplier; // Increased to 2 (Base)
                    this.width = 48;
                    this.height = 48;
                    this.scoreVal = 10;
                }
            }

            update() {
                this.y += this.vy;
                
                // Bio-ships move more erratically
                if(this.type === 'bio') {
                     this.x += Math.sin(frameCount * 0.1) * 5;
                } else {
                     this.x += Math.sin(frameCount * this.swing) * 2;
                }

                const prog = Math.min(bossIndex, 5);
                // DIFFICULTY ADJUSTMENT: Increased Enemy Fire Rate (0.0015 base)
                const baseChance = 0.0015 + (prog * 0.0005); 

                if (this.type !== 'void_mine' && Math.random() < baseChance * difficultyMultiplier) {
                    SoundManager.enemyShoot(); 
                    // Bullet speed also scales with difficulty now
                    let bulletSpeed = 7 + (difficultyMultiplier * 2);
                    let b = new Bullet(this.x, this.y + 20, true);
                    b.vy = bulletSpeed;
                    bullets.push(b);
                }

                if (this.y > canvas.height + 50) this.active = false;
                if (this.flashTimer > 0) this.flashTimer--;
            }

            // Allow passing in a context for preview rendering
            draw(c = ctx) {
                c.save();
                c.translate(this.x, this.y);
                
                if (this.type !== 'cube' && this.type !== 'bio' && this.type !== 'zarris_fighter' && this.type !== 'void_mine') {
                    c.scale(1.2, -1.2); 
                } else if (this.type === 'bio') {
                    c.scale(1.2, 1.2); 
                }

                if (this.flashTimer > 0) c.globalAlpha = 0.7;

                // --- HIGH FIDELITY ENEMY ART (MERGED USER STYLES) ---
                if (this.type === 'cube') {
                    // THE BORG CUBE (Styled)
                    let size = this.width * 0.8; 

                    // 1. Base Hull (Dark Oily Metal Gradient)
                    let hullGrad = c.createLinearGradient(-size/2, -size/2, size/2, size/2);
                    hullGrad.addColorStop(0, '#0a0a0a'); 
                    hullGrad.addColorStop(0.5, '#2a2a2a'); 
                    hullGrad.addColorStop(1, '#000');
                    c.fillStyle = hullGrad;
                    c.fillRect(-size/2, -size/2, size, size);

                    // 2. The "Greebling" (Sharp, thin circuitry)
                    c.strokeStyle = '#0f0';
                    c.lineWidth = 0.5; 
                    c.beginPath();
                    for(let i = -size/2 + 5; i < size/2; i+=8) {
                        c.moveTo(i, -size/2); c.lineTo(i, size/2);
                        c.moveTo(-size/2, i); c.lineTo(size/2, i);
                    }
                    c.stroke();

                    // 3. Pulsing Nodes & Edge Glow
                    let pulse = Math.abs(Math.sin(frameCount * 0.05));
                    c.shadowBlur = 10 * pulse;
                    c.shadowColor = '#0f0';
                    c.strokeStyle = `rgba(50, 255, 50, ${0.5 + pulse*0.5})`;
                    c.lineWidth = 1.5; 
                    c.strokeRect(-size/2, -size/2, size, size);

                    // Random active nodes
                    c.fillStyle = '#afa';
                    c.fillRect(-size/4, -size/4, 4, 4); 
                    c.fillRect(size/4 - 4, size/4 - 4, 4, 4);
                    c.shadowBlur = 0;
                } 
                else if (this.type === 'cruiser') {
                    // ROMULAN WARBIRD (Styled)
                    let upperWingGrad = c.createLinearGradient(0, -10, 0, 20);
                    upperWingGrad.addColorStop(0, '#4a8e6e'); // Highlight
                    upperWingGrad.addColorStop(1, '#2a5e3e'); // Shadow

                    let lowerWingGrad = c.createLinearGradient(0, 20, 0, 40);
                    lowerWingGrad.addColorStop(0, '#1a3e2a');
                    lowerWingGrad.addColorStop(1, '#3a6e4e');

                    // 1. Upper Hull (Curved Shoulders)
                    c.fillStyle = upperWingGrad;
                    c.beginPath();
                    c.moveTo(0, -5);
                    c.bezierCurveTo(-35, -5, -40, 10, -35, 25);
                    c.lineTo(-15, 12); c.lineTo(15, 12); c.lineTo(35, 25);
                    c.bezierCurveTo(40, 10, 35, -5, 0, -5);
                    c.fill();

                    // 2. Lower Hull (Connecting Loop)
                    c.fillStyle = lowerWingGrad;
                    c.beginPath();
                    c.moveTo(-35, 25);
                    c.quadraticCurveTo(-25, 45, 0, 40); c.quadraticCurveTo(25, 45, 35, 25);
                    c.lineTo(25, 20); c.lineTo(-25, 20); 
                    c.fill();

                    // 3. The "Head" & Singularity Core
                    c.fillStyle = '#1a3e2a';
                    c.beginPath();
                    c.ellipse(0, 5, 10, 14, 0, 0, Math.PI*2);
                    c.fill();

                    // Bright Green Core Glow in the center gap
                    c.shadowBlur = 12; c.shadowColor = '#5f5'; c.fillStyle = '#efe';
                    c.beginPath(); c.arc(0, 12, 3, 0, Math.PI*2); c.fill(); c.shadowBlur = 0;
                } 
                else if (this.type === 'bio') {
                    // SPECIES 8472 BIOSHIP (Retained High Fidelity)
                    let size = this.width * 0.6;
                    let bioGrad = c.createRadialGradient(0, 0, 2, 0, 0, size);
                    bioGrad.addColorStop(0, '#dca'); 
                    bioGrad.addColorStop(0.6, '#864'); 
                    bioGrad.addColorStop(1, '#543'); 

                    c.fillStyle = bioGrad;
                    c.beginPath();
                    c.moveTo(0, size); 
                    c.quadraticCurveTo(size, 0, size*0.5, -size);
                    c.quadraticCurveTo(-size*0.4, -size*0.2, 0, size); 
                    c.fill();

                    let pulse = Math.abs(Math.sin(frameCount * 0.1));
                    c.strokeStyle = `rgba(255, 200, 50, ${pulse})`;
                    c.lineWidth = 2;
                    c.beginPath();
                    c.moveTo(0, 10); c.lineTo(5, -10); c.lineTo(-2, -20);
                    c.stroke();
                    
                    c.shadowBlur = 10; c.shadowColor = '#ff0';
                    c.fillStyle = '#ff0'; 
                    c.beginPath(); c.arc(0, 0, 3, 0, Math.PI*2); c.fill();
                    c.shadowBlur = 0;
                }
                else if (this.type === 'obsidian') {
                    // CARDASSIAN GALOR (Retained High Fidelity)
                    let size = this.width * 0.6;
                    let hullGrad = c.createLinearGradient(0, -size, 0, size);
                    hullGrad.addColorStop(0, '#b96'); 
                    hullGrad.addColorStop(1, '#654'); 
                    c.fillStyle = hullGrad;
                    
                    c.beginPath();
                    c.moveTo(-10, -size); c.lineTo(10, -size); 
                    c.lineTo(15, 0); c.lineTo(-15, 0);
                    c.fill();
                    
                    c.beginPath();
                    c.moveTo(15, 0);
                    c.quadraticCurveTo(30, 20, 0, 30); 
                    c.quadraticCurveTo(-30, 20, -15, 0);
                    c.fill();

                    c.fillStyle = '#833';
                    c.beginPath(); c.arc(0, 15, 4, 0, Math.PI*2); c.fill();
                }
                else if (this.type === 'scarab') {
                    // JEM'HADAR FIGHTER (Retained High Fidelity)
                    let size = this.width * 0.5;
                    c.fillStyle = '#555566'; 
                    c.beginPath();
                    c.moveTo(0, size); 
                    c.lineTo(size, -size/2);
                    c.lineTo(size-5, -size); 
                    c.lineTo(-size+5, -size);
                    c.lineTo(-size, -size/2);
                    c.closePath();
                    c.fill();

                    c.shadowBlur = 8; c.shadowColor = '#b0f';
                    c.fillStyle = '#d0f';
                    c.fillRect(-5, -size, 10, 5); 
                    c.shadowBlur = 0;
                }
                else if (this.type === 'zarris_fighter') {
                    // SARRIS'S SOLDIER (Bonus Level Enemy)
                    let size = this.width * 0.7;

                    // 1. Hull Gradient (Swamp/Radioactive Green)
                    let hullGrad = c.createLinearGradient(0, -size, 0, size);
                    hullGrad.addColorStop(0, '#1a2a0a'); // Dark Shadow
                    hullGrad.addColorStop(0.5, '#3a4a1a'); // Olive
                    hullGrad.addColorStop(1, '#0f1a05'); // Dark Base
                    c.fillStyle = hullGrad;
                    
                    // 2. Asymmetrical/Jagged Shape
                    c.beginPath();
                    c.moveTo(0, size); // Tail
                    c.lineTo(size, -size*0.2); // Right Wing spike
                    c.lineTo(size*0.4, -size*0.6);
                    c.lineTo(0, -size); // Nose
                    c.lineTo(-size*0.4, -size*0.6);
                    c.lineTo(-size, -size*0.2); // Left Wing spike
                    c.closePath();
                    c.fill();

                    // 3. Armor Plating (The "Crushed" look)
                    c.strokeStyle = '#2a3a1a'; c.lineWidth = 2;
                    c.beginPath();
                    c.moveTo(0, -size); c.lineTo(0, size); // Spine
                    c.moveTo(-size, -size*0.2); c.lineTo(size, -size*0.2); // Crossbar
                    c.stroke();

                    // 4. Plasma Vents (Glowing Green Eyes)
                    c.shadowBlur = 8; c.shadowColor = '#6f0';
                    c.fillStyle = '#cf0';
                    c.beginPath();
                    c.ellipse(-12, -8, 3, 6, 0.4, 0, Math.PI*2); // Angled eyes
                    c.ellipse(12, -8, 3, 6, -0.4, 0, Math.PI*2);
                    c.fill();
                    c.shadowBlur = 0;
                }
                else if (this.type === 'void_mine') {
                    // MAGNETIC MINE (Bonus Level Hazard)
                    let r = this.width/2;

                    // 1. Core Sphere (Metallic Purple/Blue)
                    let mineGrad = c.createRadialGradient(-5, -5, 2, 0, 0, r);
                    mineGrad.addColorStop(0, '#aab'); // Shine
                    mineGrad.addColorStop(0.5, '#556'); // Metal
                    mineGrad.addColorStop(1, '#223'); // Shadow
                    c.fillStyle = mineGrad;
                    
                    c.beginPath();
                    c.arc(0, 0, r*0.7, 0, Math.PI*2);
                    c.fill();

                    // 2. The Spikes (Drawn in a loop)
                    c.fillStyle = '#445';
                    for(let i=0; i<6; i++) {
                        let angle = (i/6) * Math.PI*2 + (frameCount * 0.02); // Rotates slowly
                        let spikeLen = r;
                        
                        c.beginPath();
                        c.moveTo(Math.cos(angle)*r*0.5, Math.sin(angle)*r*0.5);
                        c.lineTo(Math.cos(angle)*spikeLen, Math.sin(angle)*spikeLen); // Tip
                        c.strokeStyle = '#667';
                        c.lineWidth = 4;
                        c.stroke();
                    }
                    
                    // 3. Magnetic Pulse (Purple Ring)
                    let pulse = Math.abs(Math.sin(frameCount * 0.1));
                    c.strokeStyle = `rgba(180, 50, 255, ${pulse})`;
                    c.lineWidth = 2;
                    c.beginPath();
                    c.arc(0, 0, r, 0, Math.PI*2);
                    c.stroke();
                }
                else {
                    // KLINGON BIRD OF PREY (Styled - Default Scout)
                    // 1. Engine Glow (Bright Orange/Red)
                    c.shadowBlur = 10; c.shadowColor = '#ff4400'; c.fillStyle = '#ff6600';
                    c.fillRect(-6, -5, 12, 4); c.shadowBlur = 0;

                    // 2. Main Hull Gradient (Rusty Metal)
                    let grad = c.createLinearGradient(-15, 0, 15, 0);
                    grad.addColorStop(0, '#3e3020'); // Dark rust shadow
                    grad.addColorStop(0.5, '#7e6040'); // Metallic bronze highlight
                    grad.addColorStop(1, '#3e3020');

                    c.fillStyle = grad;
                    // 3. The Shape (Aggressive Triangle)
                    c.beginPath();
                    c.moveTo(0, 25); // Nose
                    c.lineTo(6, 5);
                    c.lineTo(30, 20); // Right Wingtip
                    c.lineTo(22,-2);
                    c.lineTo(8, -10); // Rear right
                    c.lineTo(-8, -10); // Rear left
                    c.lineTo(-22,-2);
                    c.lineTo(-30, 20); // Left Wingtip
                    c.lineTo(-6, 5); 
                    c.closePath(); 
                    c.fill();

                    // 4. Wing Disruptors (Glowing Red tips)
                    c.fillStyle = '#cc0000';
                    c.fillRect(-31, 18, 2, 5); c.fillRect(29, 18, 2, 5);

                    // Feather plating lines
                    c.strokeStyle = '#2e2010'; c.lineWidth = 1;
                    c.beginPath();
                    c.moveTo(-22, -2); c.lineTo(-8, 5); 
                    c.moveTo(22, -2); c.lineTo(8, 5); 
                    c.stroke();
                }
                c.restore();
            }
        }

        class Boss extends Ship {
            constructor(name) {
                super(canvas.width / 2, -100, 500);
                this.name = name;
                this.width = 120;
                this.height = 100;
                this.targetY = 100;
                this.phase = 0;
                this.isBoss = true;
                
                // Progressive Boss Scaling: Bosses get +15% harder for each cycle (bossIndex)
                // This prevents the game from getting too easy if you loop for a long time
                let difficultyScale = 1 + (bossIndex * 0.15);

                // DIFFICULTY ADJUSTMENT: Boss HP Reduced by 50% -> then increased 50%
                // Base HP Values increased by ~50% from previous "easy" state
                if (name === "General Kael") {
                    this.hp = Math.floor(250 * difficultyScale); this.maxHp = this.hp; this.scoreVal = 1000;
                    this.width = 160; this.height = 100; // Reliant is wide
                } else if (name === "Void Lord") {
                    this.hp = Math.floor(400 * difficultyScale); this.maxHp = this.hp; this.scoreVal = 2000;
                    this.width = 180; this.height = 100; 
                } else if (name === "Cyber Matriarch") {
                    this.hp = Math.floor(600 * difficultyScale); this.maxHp = this.hp; this.scoreVal = 3000; 
                    this.width = 100; this.height = 180; 
                } else if (name === "Cosmic Entity") {
                    this.hp = Math.floor(900 * difficultyScale); this.maxHp = this.hp; this.scoreVal = 5000; 
                } else if (name === "Void Empress") {
                    this.hp = Math.floor(1200 * difficultyScale); this.maxHp = this.hp; this.scoreVal = 6000;
                    this.width = 200; this.height = 150; 
                } else if (name === "General Zarris") {
                    // BONUS BOSS - Very tough
                    this.hp = Math.floor(2000 * difficultyScale); this.maxHp = this.hp; this.scoreVal = 10000;
                    this.width = 180; this.height = 140; 
                }
            }

            update() {
                if (this.y < this.targetY) {
                    this.y += 1;
                } else {
                    this.x += Math.sin(frameCount * 0.02) * 3;
                    if (this.name === "Cosmic Entity" && Math.random() < 0.01) {
                        this.x = Math.random() * (canvas.width - 100) + 50;
                    }
                }

                this.x = Math.max(this.width/2, Math.min(canvas.width - this.width/2, this.x));

                const prog = Math.min(bossIndex, 5);
                // DIFFICULTY ADJUSTMENT: Bosses shoot more frequently (0.02 base)
                // Also scales slightly with difficulty multiplier over time
                let chance = (0.02 + (prog * 0.003)) * difficultyMultiplier; 

                if (Math.random() < chance) {
                      if (this.name !== "Void Empress") {
                        SoundManager.enemyShoot(); 
                        let b = new Bullet(this.x, this.y + this.height/2, true);
                        b.vy = 7 + (difficultyMultiplier * 1.5); // Faster bullets later
                        bullets.push(b);
                      }
                      
                      if (this.name === "Void Lord" || this.name === "Cyber Matriarch") {
                          let b1 = new Bullet(this.x - 20, this.y + this.height/2, true);
                          b1.vx = -2;
                          let b2 = new Bullet(this.x + 20, this.y + this.height/2, true);
                          b2.vx = 2;
                          bullets.push(b1, b2);
                      } 
                      else if (this.name === "Void Empress") {
                          SoundManager.enemyShoot();
                          let b = new Bullet(this.x, this.y + this.height/2, true);
                          b.isOrb = true; b.color = '#d0f'; 
                          b.speed = 6 + difficultyMultiplier; 
                          bullets.push(b);
                      }
                      else if (this.name === "General Zarris") {
                          // Placeholder firing logic for Zarris
                          SoundManager.enemyShoot();
                          let b = new Bullet(this.x, this.y + this.height/2, true);
                          b.color = '#0f0'; // Green plasma
                          b.speed = 8 + difficultyMultiplier;
                          bullets.push(b);
                      }
                }

                if (this.flashTimer > 0) this.flashTimer--;
                updateBossUI(this);
            }

            draw(c = ctx) {
                c.save();
                c.translate(this.x, this.y);
                if (this.flashTimer > 0) c.globalAlpha = 0.7;

                let scale = 0.8; // Standard scale for Bosses
                
                // --- MERGED BOSS ART ---
                
                if (this.name === "General Kael") {
                    // KHAN / USS RELIANT (Styled)
                    // 1. Warp Nacelles (Underneath)
                    c.fillStyle = '#889'; 
                    c.fillRect(-45*scale, 10*scale, 8*scale, 50*scale);
                    c.fillRect(37*scale, 10*scale, 8*scale, 50*scale);

                    // Blue Glow strips
                    c.shadowBlur = 8; c.shadowColor = '#00f'; c.fillStyle = '#00ffff';
                    c.fillRect(-43*scale, 15*scale, 4*scale, 40*scale);
                    c.fillRect(39*scale, 15*scale, 4*scale, 40*scale);
                    c.shadowBlur = 0;

                    // 2. Main Saucer (Clean Federation Gradient)
                    let saucerGrad = c.createRadialGradient(0, 0*scale, 5*scale, 0, 0*scale, 50*scale);
                    saucerGrad.addColorStop(0, '#fff');
                    saucerGrad.addColorStop(0.6, '#cce');
                    saucerGrad.addColorStop(1, '#99a');

                    c.fillStyle = saucerGrad;
                    c.beginPath();
                    c.arc(0, 0, 50*scale, 0, Math.PI*2);
                    c.fill();

                    // Saucer details
                    c.strokeStyle = 'rgba(150,150,180,0.5)'; c.lineWidth = 1;
                    c.beginPath(); c.arc(0, 0, 35*scale, 0, Math.PI*2); c.stroke();

                    // 3. The Rollbar & Torpedo Pod
                    c.fillStyle = '#aab'; 
                    c.fillRect(-55*scale, -18*scale, 110*scale, 10*scale);
                    // Weapons Pod
                    c.fillStyle = '#99a';
                    c.beginPath();
                    c.moveTo(-12*scale, -18*scale); c.lineTo(-16*scale, -30*scale);
                    c.lineTo(16*scale, -30*scale); c.lineTo(12*scale, -18*scale);
                    c.fill();

                    // Red Phaser/Torpedo glow
                    c.shadowBlur = 5; c.shadowColor = '#f00'; c.fillStyle = '#f00';
                    c.fillRect(-8*scale, -30*scale, 16*scale, 3*scale);
                    c.shadowBlur = 0;
                } 
                else if (this.name === "Void Lord") {
                    // NERO / NARADA (Styled)
                    // 1. Center Core (Deep oily black)
                    let coreGrad = c.createRadialGradient(0,0,0, 0,0,15*scale);
                    coreGrad.addColorStop(0, '#200');
                    coreGrad.addColorStop(1, '#000');
                    c.fillStyle = coreGrad;
                    c.beginPath();
                    c.arc(0, 0, 15*scale, 0, Math.PI*2); c.fill();

                    // 2. The Spikes (Heated Drills)
                    c.lineWidth = 2.5*scale;
                    for(let i=0; i<12; i++) { 
                        let angle = (i/12) * Math.PI * 2 + frameCount * 0.01;
                        let length = 65*scale; 

                        // Gradient: Dark root -> Fiery tip
                        let spikeGrad = c.createLinearGradient(0,0, Math.cos(angle)*length, Math.sin(angle)*length);
                        spikeGrad.addColorStop(0.2, '#100'); 
                        spikeGrad.addColorStop(0.7, '#620'); 
                        spikeGrad.addColorStop(1, '#f40'); 

                        c.strokeStyle = spikeGrad; c.beginPath();
                        c.moveTo(Math.cos(angle)*15*scale, Math.sin(angle)*15*scale);

                        // Jagged Line generator
                        let midX = Math.cos(angle) * (length*0.6) + Math.cos(angle*8 + frameCount*0.1)*5;
                        let midY = Math.sin(angle) * (length*0.6) + Math.sin(angle*8 + frameCount*0.1)*5;

                        c.lineTo(midX, midY);
                        c.lineTo(Math.cos(angle)*length, Math.sin(angle)*length);
                        c.stroke();
                    }

                    // 3. Central Drill Glow
                    c.shadowBlur = 15; c.shadowColor = '#f00';
                    c.fillStyle = `rgba(255, 50, 0, ${0.5 + Math.sin(frameCount*0.2)*0.2})`;
                    c.beginPath(); c.arc(0, 0, 8*scale, 0, Math.PI*2); c.fill();
                    c.shadowBlur = 0;
                }
                else if (this.name === "Cyber Matriarch") {
                    // BORG QUEEN (Diamond - Styled)
                    // 1. Outer Hull (Obsidian Gradient)
                    let hullGrad = c.createLinearGradient(0, -60*scale, 0, 60*scale);
                    hullGrad.addColorStop(0, '#2a2a2a'); hullGrad.addColorStop(0.5, '#000'); hullGrad.addColorStop(1, '#1a1a1a');
                    c.fillStyle = hullGrad;

                    // Sharp green outline
                    c.shadowBlur = 10; c.shadowColor = '#0f0';
                    c.strokeStyle = '#5f5'; c.lineWidth = 2*scale;

                    c.beginPath();
                    c.moveTo(0, -60*scale); c.lineTo(60*scale, 0);
                    c.lineTo(0, 60*scale); c.lineTo(-60*scale, 0);
                    c.closePath();
                    c.fill(); c.stroke();
                    c.shadowBlur = 0;

                    // 2. Inner Details
                    c.strokeStyle = '#040'; c.lineWidth = 1;
                    c.beginPath();
                    c.moveTo(0, -40*scale); c.lineTo(40*scale, 0);
                    c.lineTo(0, 40*scale); c.lineTo(-40*scale, 0); c.closePath();
                    c.stroke();

                    // 3. The Core
                    let pulse = Math.abs(Math.sin(frameCount * 0.05));
                    c.fillStyle = '#131';
                    c.beginPath(); c.arc(0, 0, 20*scale, 0, Math.PI*2); c.fill();

                    // Inner Pulsing Light
                    c.shadowBlur = 15 + 5*pulse; c.shadowColor = '#0f0';
                    c.fillStyle = `rgba(150, 255, 150, ${0.7 + pulse * 0.3})`;
                    c.beginPath(); c.arc(0, 0, 12*scale, 0, Math.PI*2); c.fill();
                    c.shadowBlur = 0;
                }
                else if (this.name === "Cosmic Entity") {
                    // Q (Energy Being - Styled)
                    // 1. The Core Flash
                    c.shadowBlur = 20; c.shadowColor = '#fff';
                    let g = c.createRadialGradient(0, 0, 2*scale, 0, 0, 45*scale);
                    g.addColorStop(0, '#fff');
                    g.addColorStop(0.3, '#eef');
                    g.addColorStop(0.6, '#c0f'); 
                    g.addColorStop(1, 'rgba(0,0,0,0)');

                    c.fillStyle = g;
                    c.beginPath(); c.arc(0, 0, 50*scale, 0, Math.PI*2); c.fill();
                    c.shadowBlur = 0;

                    // 2. Orbiting Energy Arcs
                    c.lineWidth = 2.5*scale; c.lineCap = 'round';

                    // Arc 1
                    c.strokeStyle = 'rgba(100, 220, 255, 0.8)';
                    c.beginPath();
                    c.arc(0, 0, 35*scale, frameCount*0.1, frameCount*0.1 + Math.PI);
                    c.stroke();

                    // Arc 2
                    c.strokeStyle = 'rgba(255, 100, 255, 0.8)';
                    c.beginPath();
                    c.arc(0, 0, 35*scale, -frameCount*0.12 + Math.PI/2, -frameCount*0.12 + Math.PI*1.5);
                    c.stroke();

                    // 3. Sparkles
                    c.fillStyle = '#fff';
                    let sparkAngle = frameCount * 0.3; let sparkDist = 30*scale;
                    c.fillRect(Math.cos(sparkAngle)*sparkDist, Math.sin(sparkAngle)*sparkDist, 3*scale, 3*scale);
                    c.fillRect(Math.cos(sparkAngle + 2)*sparkDist, Math.sin(sparkAngle + 2)*sparkDist, 2*scale, 2*scale);
                }
                else if (this.name === "Void Empress") {
                    // VOID EMPRESS (Scimitar / Reman Warbird)
                    c.fillStyle = '#222'; 
                    c.strokeStyle = '#555';
                    
                    c.beginPath();
                    c.moveTo(0, 70); // Nose
                    c.quadraticCurveTo(40, 40, 100, 20); 
                    c.lineTo(100, -40); 
                    c.quadraticCurveTo(50, -20, 0, -50); 
                    c.quadraticCurveTo(-50, -20, -100, -40); 
                    c.lineTo(-100, 20);
                    c.quadraticCurveTo(-40, 40, 0, 70); 
                    c.fill();
                    c.stroke();
                    
                    c.strokeStyle = '#4a4'; c.lineWidth = 1;
                    c.beginPath();
                    c.moveTo(0,0); c.lineTo(80, -10);
                    c.moveTo(0,0); c.lineTo(-80, -10);
                    c.stroke();
                    
                    let pulse = Math.abs(Math.sin(frameCount * 0.1));
                    c.shadowBlur = 20 + 10*pulse; c.shadowColor = '#0f0';
                    c.fillStyle = `rgba(50, 255, 50, ${pulse})`;
                    c.beginPath(); c.arc(0, 20, 8, 0, Math.PI*2); c.fill();
                    c.shadowBlur = 0;
                }
                else if (this.name === "General Zarris") {
                    // SARRIS (The Fatu-Krey)
                    // 1. Main Hull (Cruel, dark green metal)
                    c.fillStyle = '#182211'; // Black-Green
                    c.strokeStyle = '#4a5522'; // Lighter edges
                    c.lineWidth = 3;

                    c.beginPath();
                    // Central Body
                    c.moveTo(0, 60*scale); // Rear Tail
                    c.lineTo(20*scale, 0);
                    // Right Pincer
                    c.lineTo(65*scale, -25*scale); // Spike tip
                    c.lineTo(40*scale, -50*scale); // Inner recess
                    c.lineTo(10*scale, -70*scale); // Nose
                    // Left Pincer
                    c.lineTo(-10*scale, -70*scale);
                    c.lineTo(-40*scale, -50*scale);
                    c.lineTo(-65*scale, -25*scale); // Spike tip
                    c.lineTo(-20*scale, 0);
                    c.closePath();
                    c.fill();
                    c.stroke();

                    // 2. Internal Green Glow (Radioactive)
                    c.shadowBlur = 20; c.shadowColor = '#3f0';
                    c.fillStyle = '#5f0';
                    
                    // Glowing Ports on the Pincers
                    c.beginPath();
                    c.arc(-40*scale, -35*scale, 5*scale, 0, Math.PI*2);
                    c.arc(40*scale, -35*scale, 5*scale, 0, Math.PI*2);
                    c.fill();
                    
                    // 3. Sarris's Command Deck
                    c.fillStyle = '#cf0';
                    c.fillRect(-6*scale, -55*scale, 12*scale, 10*scale);
                    c.shadowBlur = 0;
                }

                c.restore();
            }
        }

        // --- Game Logic Functions ---

        // IMPROVEMENT 2: Formations / Squads
        function spawnEnemies() {
            if (bossActive || spawnDelay > 0) return; 

            // DIFFICULTY ADJUSTMENT: Increased Spawn Rate
            // Base chance for random spawns (Original was ~0.014, we reduced to 0.006, now bumping to 0.012)
            if (Math.random() < 0.012 * difficultyMultiplier) {
                 enemies.push(new Enemy(getRandomEnemyType()));
            }
            
            // Chance for a Squad (bumped to 0.005)
            if (Math.random() < 0.005 * difficultyMultiplier) {
                spawnSquadron();
            }
        }
        
        function getRandomEnemyType() {
            const rand = Math.random();
            
            // Bonus Level Check: Zarris is the 6th boss (index 5)
            if (bossIndex === 5) {
                if (rand > 0.95) return 'void_mine';
                return 'zarris_fighter';
            }

            // Phase 1: Early Game (0-1 Bosses defeated)
            if (bossIndex < 2) {
                // Small chance to see a Cube early (Level 2)
                if (bossIndex === 1 && rand > 0.97) return 'cube'; 
                if (bossIndex === 1 && rand > 0.90) return 'obsidian';
                return rand > 0.7 ? 'cruiser' : 'scout';
            }
            
            // Phase 2: Mid Game (2-3 Bosses defeated)
            if (bossIndex < 4) {
                if (rand > 0.90) return 'cube';     // 10% chance (Cyber Fortress)
                if (rand > 0.75) return 'obsidian'; // 15% chance (Golden Enforcer)
                if (rand > 0.30) return 'scarab';   // 45% chance (Void Stinger)
                return 'cruiser';                   // 30% chance
            }
            
            // Phase 3: Late Game (4+ Bosses defeated)
            if (rand > 0.80) return 'cube';     // 20% chance (Increased from 10%)
            if (rand > 0.60) return 'bio';      // 20% chance (Organic Terror)
            if (rand > 0.30) return 'obsidian'; // 30% chance
            return 'scarab';                    // 30% chance
        }
        
        function spawnSquadron() {
            // Squads can now be Scouts or Scarabs depending on difficulty
            const type = (bossIndex > 2 && Math.random() > 0.5) ? 'scarab' : 'scout';
            const pattern = Math.random() > 0.5 ? 'V' : 'LINE';
            const startX = Math.random() * (canvas.width - 200) + 100;
            
            if (pattern === 'V') {
                enemies.push(new Enemy(type, startX, -50));
                enemies.push(new Enemy(type, startX - 40, -80));
                enemies.push(new Enemy(type, startX + 40, -80));
            } else {
                enemies.push(new Enemy(type, startX, -50));
                enemies.push(new Enemy(type, startX + 50, -50));
                enemies.push(new Enemy(type, startX - 50, -50));
            }
        }
        
        function spawnCoins(x, y, amount) {
            for(let i=0; i<amount; i++) {
                coins.push(new Coin(x, y));
            }
        }

        function checkBossSpawn() {
            if (!bossActive && score >= nextBossScore && spawnDelay === 0) {
                bossActive = true;
                SoundManager.bossAlarm(); 
                let name = bossList[bossIndex % bossList.length];
                currentBoss = new Boss(name);
                
                document.getElementById('boss-hud').style.display = 'flex';
                document.getElementById('boss-name').innerText = "WARNING: " + name;
                
                getGeminiTaunt(name);
                
                // BONUS LEVEL TRIGGER
                if (name === "General Zarris") {
                    activateBonusLevel();
                }
            }
        }
        
        function activateBonusLevel() {
            // Transform Player Logic
            player.isProtector = true;
            // Full heal for the bonus round
            player.hp = player.maxHp; 
            updateHealth();
            
            // Visual Flare
            showComms("COMMAND", "SIGMA 13 ACTIVATED. SHIP RECONFIGURING.");
            triggerShake(20, 5);
            
            // Could change background or music here in future
        }
        
        function updateBossUI(boss) {
            const fill = document.getElementById('boss-health-fill');
            const pct = Math.max(0, (boss.hp / boss.maxHp) * 100);
            fill.style.width = pct + "%";
        }

        function spawnUpgrades() {
            if (Math.random() < 0.002) {
                upgrades.push(new Upgrade(Math.random() * (canvas.width - 60) + 30, -30));
            }
        }

        function checkCollisions() {
            // 1. Bullets
            bullets.forEach(b => {
                if (!b.active) return;
                
                if (!b.isEnemy) {
                    let hitBoss = false;
                    if (bossActive && currentBoss) {
                        if (Math.abs(b.x - currentBoss.x) < currentBoss.width/2 && Math.abs(b.y - currentBoss.y) < currentBoss.height/2) {
                            b.active = false;
                            hitBoss = true;
                            currentBoss.takeDamage(player.damage); 
                            triggerShake(3, 2); 
                            if (!currentBoss.active) handleBossDefeat();
                        }
                    } 
                    
                    if (!hitBoss) {
                        enemies.forEach(e => {
                            if (!e.active || !b.active) return;
                            if (Math.abs(b.x - e.x) < e.width/2 && Math.abs(b.y - e.y) < e.height/2) {
                                b.active = false;
                                e.takeDamage(player.damage); 
                                if (!e.active) {
                                    score += e.scoreVal;
                                    spawnCoins(e.x, e.y, e.type === 'cube' ? 5 : e.type === 'cruiser' ? 2 : 1);
                                    SoundManager.explode(); 
                                }
                            }
                        });
                    }
                } else {
                    if (Math.abs(b.x - player.x) < player.width/2 - 10 && Math.abs(b.y - player.y) < player.height/2) {
                        b.active = false;
                        player.takeDamage(10);
                        triggerShake(15, 10); 
                        updateHealth();
                    }
                }
            });

            // 2. Rockets
            rockets.forEach(r => {
                if (!r.active) return;
                
                let hitBoss = false;
                if (bossActive && currentBoss) {
                     if (Math.hypot(r.x - currentBoss.x, r.y - currentBoss.y) < currentBoss.width/2) {
                        r.active = false;
                        hitBoss = true;
                        currentBoss.takeDamage(5 * player.damage); 
                        for(let i=0; i<5; i++) particles.push(new Particle(r.x, r.y, '#ff9900'));
                        triggerShake(8, 5); 
                        SoundManager.explode(); 
                        if (!currentBoss.active) handleBossDefeat();
                    }
                } 
                
                if (!hitBoss) {
                    enemies.forEach(e => {
                        if (!e.active || !r.active) return;
                        if (Math.hypot(r.x - e.x, r.y - e.y) < e.width/2 + 10) {
                            r.active = false;
                            e.takeDamage(10 * player.damage); 
                            for(let i=0; i<5; i++) particles.push(new Particle(r.x, r.y, '#ff9900'));
                            triggerShake(5, 3); 
                            if (!e.active) {
                                score += e.scoreVal;
                                spawnCoins(e.x, e.y, e.type === 'cube' ? 5 : 1);
                                SoundManager.explode(); 
                            }
                        }
                    });
                }
            });

            // 3. Mines
            mines.forEach(m => {
                if (!m.active) return;
                
                let hitBoss = false;
                if (bossActive && currentBoss) {
                     if (Math.abs(m.x - currentBoss.x) < currentBoss.width/2 && Math.abs(m.y - currentBoss.y) < currentBoss.height/2) {
                        m.active = false;
                        hitBoss = true;
                        currentBoss.takeDamage(20 * player.damage);
                        for(let i=0; i<10; i++) particles.push(new Particle(m.x, m.y, '#cc00cc'));
                        triggerShake(12, 8); 
                        SoundManager.explode(true); 
                        if (!currentBoss.active) handleBossDefeat();
                    }
                } 
                
                if (!hitBoss) {
                    enemies.forEach(e => {
                        if (!e.active || !m.active) return;
                        if (Math.abs(m.x - e.x) < e.width/2 + 10 && Math.abs(m.y - e.y) < e.height/2 + 10) {
                            m.active = false;
                            e.takeDamage(50 * player.damage); 
                            for(let i=0; i<10; i++) particles.push(new Particle(m.x, m.y, '#cc00cc'));
                            triggerShake(8, 5);
                            if (!e.active) {
                                score += e.scoreVal;
                                spawnCoins(e.x, e.y, 3);
                                SoundManager.explode(true); 
                            }
                        }
                    });
                }
            });

            document.getElementById('score-display').innerText = `Score: ${score}`;

            // Boss vs Player
            if (bossActive && currentBoss) {
                 if (Math.abs(currentBoss.x - player.x) < (player.width + currentBoss.width)/2.5 && Math.abs(currentBoss.y - player.y) < (player.height + currentBoss.height)/2.5) {
                     player.takeDamage(5); 
                     triggerShake(5, 5);
                     updateHealth();
                 }
            }

            // Enemies vs Player
            enemies.forEach(e => {
                if (!e.active) return;
                if (Math.abs(e.x - player.x) < (player.width + e.width)/3 && Math.abs(e.y - player.y) < (player.height + e.height)/3) {
                    e.takeDamage(100); 
                    player.takeDamage(20); 
                    triggerShake(15, 10); 
                    SoundManager.explode(true); 
                    updateHealth();
                }
            });
            
            // Upgrades
            upgrades.forEach(u => {
                if (!u.active) return;
                const dx = player.x - u.x;
                const dy = player.y - u.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < (player.width/2 + u.width/2)) {
                    u.active = false;
                    SoundManager.powerup(); 
                    player.activateUpgrade(u.type);
                }
            });
            
            // Coins
            coins.forEach(c => {
                if (!c.active) return;
                const dx = player.x - c.x;
                const dy = player.y - c.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < (player.width/2 + c.width/2)) {
                    c.active = false;
                    SoundManager.coin();
                    player.coins++;
                    document.getElementById('latinum-display').innerText = `Credits: ${player.coins}`;
                }
            });
        }
        
        function handleBossDefeat() {
            triggerShake(60, 20); 
            SoundManager.explode(true); 
            score += currentBoss.scoreVal;
            spawnCoins(currentBoss.x, currentBoss.y, 30); 
            bossActive = false;
            currentBoss = null;
            bossIndex++;
            nextBossScore = score + 1000; 
            
            // REDUCED DELAY: Changed from 1200 (20s) to 180 (3s)
            spawnDelay = 180;
            
            document.getElementById('boss-hud').style.display = 'none';
            player.hp = Math.min(player.maxHp, player.hp + 50);
            updateHealth();
        }

        function updateHealth() {
            const pct = Math.max(0, Math.ceil((player.hp / player.maxHp) * 100));
            document.getElementById('health-display').innerText = `Shields: ${pct}%`;
            document.getElementById('health-display').style.color = pct < 30 ? '#ff3300' : '#00d4ff';
            
            if (player.hp <= 0) {
                endGame();
            }
        }
        
        function updateTimersUI() {
            const wingmanBar = document.getElementById('status-wingman');
            const rapidBar = document.getElementById('status-rapid');
            const rocketBar = document.getElementById('status-rocket');
            const mineBar = document.getElementById('status-mine');
            
            const updateBar = (bar, timer) => {
                if (timer > 0) {
                    bar.style.display = 'block';
                    bar.querySelector('.status-fill').style.width = (timer / player.maxTimer * 100) + '%';
                } else {
                    bar.style.display = 'none';
                }
            };
            
            updateBar(wingmanBar, player.wingmanTimer);
            updateBar(rapidBar, player.rapidTimer);
            updateBar(rocketBar, player.rocketTimer);
            updateBar(mineBar, player.mineTimer);
        }

        function initGame() {
            score = 0;
            frameCount = 0;
            difficultyMultiplier = 1;
            spawnDelay = 0; 
            
            // Reset Lives on Fresh Start
            livesRemaining = 3;
            
            bossActive = false;
            bossIndex = 0;
            nextBossScore = 1000;
            currentBoss = null;
            document.getElementById('boss-hud').style.display = 'none';
            document.getElementById('new-highscore-msg').style.display = 'none';

            enemies = [];
            bullets = [];
            particles = [];
            upgrades = [];
            coins = [];
            rockets = [];
            mines = [];
            planets = []; 
            floatingTexts = []; 
            
            player = new Player();
            player.x = canvas.width / 2;
            player.y = canvas.height - 100;
            player.targetX = player.x;
            player.targetY = player.y;
            // Ensure player starts as normal ship
            player.isProtector = false;
            
            updateUltimateUI();
            document.getElementById('score-display').innerText = `Score: 0`;
            document.getElementById('latinum-display').innerText = `Credits: 0`;
            updateHealth();
            updateTimersUI();
            
            stars = [];
            for(let i=0; i<150; i++) stars.push(new Star());
            for(let i=0; i<3; i++) planets.push(new Planet());
        }

        function endGame() {
            gameState = 'GAMEOVER';
            document.getElementById('game-over-screen').classList.remove('hidden');
            document.getElementById('ui-layer').classList.add('hidden');
            document.getElementById('boss-hud').style.display = 'none';

            // Check if we have lives left
            if (livesRemaining > 0) {
                startContinuePhase();
            } else {
                showFinalGameOver();
            }
        }

        function startContinuePhase() {
            document.getElementById('game-over-title').innerText = "CRITICAL FAILURE";
            document.getElementById('continue-section').classList.remove('hidden');
            document.getElementById('final-options').classList.add('hidden');
            document.getElementById('lives-display').innerText = livesRemaining;
            
            let timeLeft = 15;
            const timerEl = document.getElementById('continue-timer');
            const btn = document.getElementById('continue-btn');
            
            timerEl.innerText = timeLeft;
            timerEl.style.color = '#00d4ff';
            btn.disabled = false;
            btn.style.opacity = "1";

            if (continueInterval) clearInterval(continueInterval);
            
            continueInterval = setInterval(() => {
                timeLeft--;
                timerEl.innerText = timeLeft;
                
                if (timeLeft <= 5) {
                    timerEl.style.color = '#ff3300'; // Urgent red
                    SoundManager.playTone(200, 'square', 0.1); // Beep
                }

                if (timeLeft <= 0) {
                    clearInterval(continueInterval);
                    showFinalGameOver();
                }
            }, 1000);
        }

        function showFinalGameOver() {
            if (continueInterval) clearInterval(continueInterval);
            
            document.getElementById('game-over-title').innerText = "MISSION FAILED";
            document.getElementById('continue-section').classList.add('hidden');
            document.getElementById('final-options').classList.remove('hidden');

            if (score > highScore) {
                highScore = score;
                localStorage.setItem('trek1942_highscore', highScore);
                document.getElementById('highscore-display').innerText = `High: ${highScore}`;
                document.getElementById('new-highscore-msg').style.display = 'block';
            } else {
                document.getElementById('new-highscore-msg').style.display = 'none';
            }
            
            document.getElementById('final-score').innerText = `Final Score: ${score}`;
            document.getElementById('best-score').innerText = `High Score: ${highScore}`;
        }

        // Continue Button Listener
        document.getElementById('continue-btn').addEventListener('click', () => {
            if (continueInterval) clearInterval(continueInterval);
            livesRemaining--;
            
            // Respawn Logic
            gameState = 'PLAYING';
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('ui-layer').classList.remove('hidden');
            
            // Restore Boss HUD if Active
            if (bossActive && currentBoss) {
                document.getElementById('boss-hud').style.display = 'flex';
            }
            
            // 1. Heal Player
            player.hp = player.maxHp;
            player.active = true;
            player.x = canvas.width / 2;
            player.y = canvas.height - 100;
            player.targetX = player.x;
            player.targetY = player.y;
            
            // 2. Grant temporary invincibility (3 seconds)
            player.invincible = true;
            setTimeout(() => {
                if(player) player.invincible = false;
            }, 3000);

            // 3. Clear immediate threats (Optional but fair)
            bullets = []; // Clear all bullets
            enemies.forEach(e => e.takeDamage(500)); // Nuke screen slightly
            
            updateHealth();
            SoundManager.powerup(); // Play a sound for respawn
        });

        function gameLoop() {
            requestAnimationFrame(gameLoop);

            ctx.save();
            if (shakeDuration > 0) {
                const dx = (Math.random() - 0.5) * shakeMagnitude;
                const dy = (Math.random() - 0.5) * shakeMagnitude;
                ctx.translate(dx, dy);
                shakeDuration--;
            }

            if (flashDuration > 0) {
                ctx.fillStyle = '#fff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                flashDuration--;
                ctx.restore();
                return;
            }

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw Warp Stars
            stars.forEach(s => {
                s.update();
                s.draw();
            });
            
            // Draw Planets
            planets.forEach(p => {
                p.update();
                p.draw();
            });

            if (gameState === 'PLAYING') {
                frameCount++;
                if (spawnDelay > 0) spawnDelay--;
                if (frameCount % 1200 === 0) difficultyMultiplier += 0.05;

                player.update();
                player.draw();

                checkBossSpawn();
                spawnEnemies();
                spawnUpgrades();

                if (bossActive && currentBoss) {
                    currentBoss.update();
                    currentBoss.draw();
                }

                enemies.forEach(e => e.update());
                enemies.forEach(e => e.draw());
                enemies = enemies.filter(e => e.active);

                upgrades.forEach(u => u.update());
                upgrades.forEach(u => u.draw());
                upgrades = upgrades.filter(u => u.active);
                
                coins.forEach(c => c.update());
                coins.forEach(c => c.draw());
                coins = coins.filter(c => c.active);

                bullets.forEach(b => b.update());
                bullets.forEach(b => b.draw());
                bullets = bullets.filter(b => b.active);
                
                rockets.forEach(r => r.update());
                rockets.forEach(r => r.draw());
                rockets = rockets.filter(r => r.active);

                mines.forEach(m => m.update());
                mines.forEach(m => m.draw());
                mines = mines.filter(m => m.active);

                particles.forEach(p => p.update());
                particles.forEach(p => p.draw());
                particles = particles.filter(p => p.life > 0);
                
                floatingTexts.forEach(t => {
                    t.update();
                    t.draw();
                });
                floatingTexts = floatingTexts.filter(t => t.life > 0);

                checkCollisions();
            }
            
            ctx.restore();
        }

        document.getElementById('start-btn').addEventListener('click', () => {
            SoundManager.init(); 
            initGame();
            gameState = 'PLAYING';
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('ui-layer').classList.remove('hidden');
        });

        document.getElementById('restart-btn').addEventListener('click', () => {
            SoundManager.init(); 
            initGame();
            gameState = 'PLAYING';
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('ui-layer').classList.remove('hidden');
        });
        
        // New Listener for Home Button
        document.getElementById('home-btn').addEventListener('click', () => {
            gameState = 'START'; // Reset state logic
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('start-screen').classList.remove('hidden');
            // UI Layer is already hidden by endGame()
        });

        // Initialize stars/planets for background
        for(let i=0; i<150; i++) stars.push(new Star());
        for(let i=0; i<3; i++) planets.push(new Planet());
        gameLoop();

    </script>
</body>
</html>