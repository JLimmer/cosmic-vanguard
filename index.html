<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cosmic Vanguard: Stellar Defense</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden; /* Prevent scrolling */
            touch-action: none; /* Prevent default touch gestures */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto; /* Enable clicking buttons */
        }

        .hud-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #00d4ff; /* Sci-fi blue */
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            text-shadow: 0 0 5px #00d4ff;
            width: 100%;
        }

        /* HUD Buttons */
        .hud-btn {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00d4ff;
            color: #00d4ff;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            pointer-events: auto;
            text-transform: uppercase;
            font-weight: bold;
        }
        
        .hud-btn:active {
            background: #00d4ff;
            color: #000;
        }
        
        #upgrade-btn {
            border-color: #ffcc00;
            color: #ffcc00;
        }

        .status-container {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 5px;
            pointer-events: none;
        }

        .status-bar {
            height: 8px;
            width: 150px;
            background: rgba(0,0,0,0.5);
            border: 1px solid #555;
            display: none; /* Hidden by default */
            position: relative;
            overflow: hidden; /* Added to handle stacked percentages > 100% */
        }

        .status-fill {
            height: 100%;
            width: 100%;
            transition: width 0.1s linear;
        }

        .status-label {
            font-size: 12px;
            color: #fff;
            position: absolute;
            top: -14px;
            left: 0;
        }
        
        /* Ultimate Button */
        #ultimate-container {
            position: absolute;
            bottom: 40px;
            right: 20px;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 20;
        }

        #ultimate-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: radial-gradient(circle, #444, #222);
            border: 3px solid #555;
            color: #888;
            font-weight: bold;
            font-size: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            box-shadow: 0 0 10px #000;
            cursor: not-allowed;
            transition: all 0.3s;
            text-shadow: none;
            user-select: none;
        }

        #ultimate-btn.ready {
            background: radial-gradient(circle, #ff3300, #990000);
            border-color: #ff9900;
            color: #fff;
            box-shadow: 0 0 20px #ff3300;
            cursor: pointer;
            animation: pulse 1.5s infinite;
        }
        
        #ultimate-label {
            margin-top: 5px;
            color: #888;
            font-size: 12px;
            text-transform: uppercase;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
        }
        
        /* Upgrade Button (Bottom Left) */
        #upgrade-container {
            position: absolute;
            bottom: 40px;
            left: 20px;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 20;
        }

        #upgrade-btn-bottom {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: radial-gradient(circle, #443300, #221100);
            border: 3px solid #ffcc00;
            color: #ffcc00;
            font-weight: bold;
            font-size: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            box-shadow: 0 0 10px #ffcc00;
            cursor: pointer;
            transition: all 0.2s;
            text-shadow: none;
            user-select: none;
        }
        
        #upgrade-btn-bottom:active {
            transform: scale(0.95);
            background: #ffcc00;
            color: #000;
        }

        #upgrade-label {
            margin-top: 5px;
            color: #ffcc00;
            font-size: 12px;
            text-transform: uppercase;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 20px #ff3300; }
            50% { transform: scale(1.1); box-shadow: 0 0 40px #ff3300; }
            100% { transform: scale(1); box-shadow: 0 0 20px #ff3300; }
        }
        
        /* Boss HUD */
        #boss-hud {
            position: absolute;
            top: 110px; 
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            display: none; 
            flex-direction: column;
            align-items: center;
            z-index: 5;
        }
        
        #boss-name {
            color: #ff3300;
            font-size: 24px;
            font-weight: bold;
            text-transform: uppercase;
            text-shadow: 0 0 15px #ff0000;
            margin-bottom: 5px;
            letter-spacing: 2px;
            background-color: rgba(0,0,0,0.6);
            padding: 2px 10px;
            border-radius: 4px;
        }
        
        #boss-health-bar {
            width: 100%;
            height: 20px;
            background: #330000;
            border: 2px solid #ff3300;
            border-radius: 10px;
            overflow: hidden;
        }
        
        #boss-health-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff3300, #ff9900);
            transition: width 0.2s;
        }
        
        /* Comms Panel (Gemini) */
        #comms-panel {
            position: absolute;
            top: 160px;
            width: 80%;
            left: 10%;
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid #00d4ff;
            border-radius: 10px;
            padding: 10px;
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 4;
            transition: opacity 0.5s;
        }
        #comms-title {
            color: #ff9900;
            font-size: 12px;
            text-transform: uppercase;
            margin-bottom: 5px;
            animation: blink 1s infinite;
        }
        #comms-text {
            color: #fff;
            font-style: italic;
            text-align: center;
            font-size: 14px;
            line-height: 1.4;
        }
        
        @keyframes blink { 50% { opacity: 0.5; } }
        
        /* Pause & Upgrade Overlay */
        #pause-screen, #upgrade-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 30;
            pointer-events: auto;
        }
        
        #pause-text, #upgrade-title {
            color: #00d4ff;
            font-size: 30px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 5px;
            text-shadow: 0 0 10px #00d4ff;
            margin-bottom: 20px;
            text-align: center;
        }
        
        /* Upgrade Grid */
        .upgrade-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            width: 90%;
            max-width: 500px;
            margin-bottom: 20px;
        }
        
        .upgrade-card {
            background: rgba(0, 50, 100, 0.5);
            border: 1px solid #00d4ff;
            border-radius: 10px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        
        .upgrade-name { color: #fff; font-weight: bold; margin-bottom: 5px; }
        .upgrade-cost { color: #ffcc00; font-size: 14px; margin-bottom: 10px; }
        .upgrade-buy-btn {
            background: #cc3333;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        .upgrade-buy-btn:disabled {
            background: #555;
            color: #888;
            cursor: not-allowed;
        }
        
        #current-latinum {
            color: #ffcc00;
            font-size: 24px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff9900;
        }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 10;
        }

        h1 {
            color: #ff9900; /* Sci-fi orange */
            font-size: 40px;
            margin-bottom: 10px;
            text-align: center;
            text-shadow: 0 0 10px #ff9900;
        }

        p {
            color: #ccc;
            text-align: center;
            max-width: 80%;
            line-height: 1.5;
        }

        .btn {
            margin-top: 30px;
            padding: 15px 40px;
            background: #cc3333; /* Sci-fi red */
            color: white;
            border: none;
            border-radius: 25px; 
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 15px #cc3333;
            transition: transform 0.1s;
        }

        .btn:active {
            transform: scale(0.95);
        }

        .hidden {
            display: none !important;
        }

        /* LCARS decorative bars */
        .lcars-bar {
            height: 10px;
            background: linear-gradient(90deg, #ff9900 20%, #cc3333 50%, #99ccff 80%);
            width: 100%;
            position: absolute;
            bottom: 0;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="hud-row">
                <button id="pause-btn" class="hud-btn">PAUSE</button>
                <div id="score-display">0</div>
                <button id="mute-btn" class="hud-btn">SND: ON</button>
            </div>
            <div class="hud-row" style="justify-content: center; margin-top: -10px;">
                 <div id="highscore-display" style="color: #ffcc00; font-size: 14px;">High: 0</div>
            </div>
            <div class="hud-row" style="justify-content: space-between; margin-top: 0px;">
                <div id="latinum-display" style="color: #ffcc00; font-weight: bold;">Credits: 0</div>
                <div id="health-display">Shields: 100%</div>
            </div>
            
            <div class="status-container">
                <div id="status-wingman" class="status-bar">
                    <span class="status-label">Fighter Support</span>
                    <div class="status-fill" style="background-color: #ffcc00;"></div>
                </div>
                <div id="status-rapid" class="status-bar">
                    <span class="status-label">Laser Overcharge</span>
                    <div class="status-fill" style="background-color: #ff3300;"></div>
                </div>
                <div id="status-rocket" class="status-bar">
                    <span class="status-label">Homing Rockets</span>
                    <div class="status-fill" style="background-color: #ff9900;"></div>
                </div>
                <div id="status-mine" class="status-bar">
                    <span class="status-label">Plasma Mines</span>
                    <div class="status-fill" style="background-color: #cc00cc;"></div>
                </div>
            </div>
        </div>
        
        <!-- Comms Panel -->
        <div id="comms-panel">
            <div id="comms-title">Incoming Transmission</div>
            <div id="comms-text">...Decoding Subspace Signal...</div>
        </div>
        
        <!-- Upgrade Button (Bottom Left) -->
        <div id="upgrade-container">
            <div id="upgrade-btn-bottom">OPEN<br>SHOP</div>
            <div id="upgrade-label">Fabricator</div>
        </div>
        
        <!-- Ultimate Button -->
        <div id="ultimate-container">
            <div id="ultimate-btn">CHARGING</div>
            <div id="ultimate-label">Nova Bomb</div>
        </div>
        
        <!-- Boss HUD -->
        <div id="boss-hud">
            <div id="boss-name">Warning: Boss Approaching</div>
            <div id="boss-health-bar">
                <div id="boss-health-fill"></div>
            </div>
        </div>
        
        <div class="lcars-bar"></div>
    </div>
    
    <div id="pause-screen">
        <div id="pause-text">SIMULATION PAUSED</div>
        <button id="resume-btn" class="btn">RESUME</button>
        <button id="mute-btn" class="btn" style="margin-top: 10px; background: #0099ff;">SOUND: ON</button>
    </div>
    
    <!-- Upgrade Screen -->
    <div id="upgrade-screen">
        <div id="upgrade-title">Ship Fabricator</div>
        <div id="current-latinum">Credits: 0</div>
        <div class="upgrade-grid">
            <div class="upgrade-card">
                <div class="upgrade-name">Hull Repair</div>
                <div class="upgrade-cost">Cost: 50</div>
                <div style="color:#ccc; font-size:12px; margin-bottom:5px;">Restores 50 HP</div>
                <button class="upgrade-buy-btn" onclick="buyUpgrade('repair', 50)">FABRICATE</button>
            </div>
            <div class="upgrade-card">
                <div class="upgrade-name">Shield Harmonics</div>
                <div class="upgrade-cost">Cost: 100</div>
                <div style="color:#ccc; font-size:12px; margin-bottom:5px;">+20 Max Shields</div>
                <button class="upgrade-buy-btn" onclick="buyUpgrade('maxhp', 100)">FABRICATE</button>
            </div>
            <div class="upgrade-card">
                <div class="upgrade-name">Laser Power</div>
                <div class="upgrade-cost">Cost: 200</div>
                <div style="color:#ccc; font-size:12px; margin-bottom:5px;">+1 Damage/Shot</div>
                <button class="upgrade-buy-btn" onclick="buyUpgrade('damage', 200)">FABRICATE</button>
            </div>
            <div class="upgrade-card">
                <div class="upgrade-name">Cooling Coils</div>
                <div class="upgrade-cost">Cost: 150</div>
                <div style="color:#ccc; font-size:12px; margin-bottom:5px;">+10% Fire Rate</div>
                <button class="upgrade-buy-btn" onclick="buyUpgrade('firerate', 150)">FABRICATE</button>
            </div>
        </div>
        <button id="close-upgrade-btn" class="btn">RETURN TO BATTLE</button>
    </div>

    <div id="start-screen">
        <h1>Cosmic Vanguard</h1>
        <p>Command the Vanguard Starship.</p>
        <p>Touch anywhere to move relative to your finger.</p>
        <button class="btn" id="start-btn">Engage</button>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1>Mission Failed</h1>
        <p id="final-score">Score: 0</p>
        <p id="best-score" style="color: #888; margin-top: 5px;">High Score: 0</p>
        <p id="new-highscore-msg" style="color: #ffcc00; font-weight: bold; display: none;">NEW HIGH SCORE!</p>
        <button class="btn" id="restart-btn">Re-Initialize</button>
    </div>

    <script>
        // --- Gemini API Config ---
        const apiKey = ""; // Provided by environment at runtime

        async function getGeminiTaunt(bossName) {
            if (!apiKey) {
                console.warn("API Key missing, skipping Gemini call.");
                showComms(bossName, "I will destroy you, Captain!"); // Fallback
                return;
            }

            // Updated prompt for generic sci-fi setting
            const prompt = `You are the galactic villain ${bossName}. Give me a short, threatening, 1-sentence taunt to a Space Fleet Captain. Do not use quotes.`;
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }]
                    })
                });

                const data = await response.json();
                const text = data.candidates?.[0]?.content?.parts?.[0]?.text || "Your destruction is imminent.";
                showComms(bossName, text);
            } catch (error) {
                console.error("Gemini Error:", error);
                showComms(bossName, "Communications disrupted...");
            }
        }

        function showComms(sender, message) {
            const panel = document.getElementById('comms-panel');
            const title = document.getElementById('comms-title');
            const text = document.getElementById('comms-text');
            
            title.innerText = `INCOMING SIGNAL: ${sender}`;
            text.innerText = message;
            panel.style.display = 'flex';
            
            // Hide after 5 seconds
            setTimeout(() => {
                panel.style.display = 'none';
            }, 5000);
        }

        // --- Audio System (Synthesizer) ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;
        let isMuted = false;

        const SoundManager = {
            init: () => {
                if (!audioCtx) {
                    audioCtx = new AudioContext();
                } else if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
            },
            
            playTone: (freq, type, duration, vol = 0.1) => {
                if (isMuted || !audioCtx) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            },

            shoot: () => {
                if (isMuted || !audioCtx) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.15);
                gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.15);
            },

            enemyShoot: () => {
                if (isMuted || !audioCtx) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(300, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(100, audioCtx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.03, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.2);
            },

            explode: (large = false) => {
                if (isMuted || !audioCtx) return;
                const bufferSize = audioCtx.sampleRate * (large ? 1.0 : 0.3);
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 1000;
                gain.gain.setValueAtTime(large ? 0.3 : 0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + (large ? 1.0 : 0.3));
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                noise.start();
            },
            
            powerup: () => {
                if (isMuted || !audioCtx) return;
                const now = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(660, now);
                osc.frequency.setValueAtTime(880, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 0.3);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(now + 0.3);
            },
            
            coin: () => {
                if (isMuted || !audioCtx) return;
                const now = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(1200, now);
                osc.frequency.setValueAtTime(1800, now + 0.05);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 0.1);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(now + 0.1);
            },
            
            bossAlarm: () => {
                 if (isMuted || !audioCtx) return;
                 const now = audioCtx.currentTime;
                 const osc = audioCtx.createOscillator();
                 const gain = audioCtx.createGain();
                 osc.type = 'triangle';
                 osc.frequency.setValueAtTime(400, now);
                 osc.frequency.linearRampToValueAtTime(800, now + 0.5);
                 osc.frequency.linearRampToValueAtTime(400, now + 1.0);
                 gain.gain.setValueAtTime(0.2, now);
                 gain.gain.linearRampToValueAtTime(0.01, now + 1.0);
                 osc.connect(gain);
                 gain.connect(audioCtx.destination);
                 osc.start();
                 osc.stop(now + 1.0);
            },
            
            ultimate: () => {
                 if (isMuted || !audioCtx) return;
                 const now = audioCtx.currentTime;
                 const osc = audioCtx.createOscillator();
                 const gain = audioCtx.createGain();
                 osc.type = 'sawtooth';
                 osc.frequency.setValueAtTime(100, now);
                 osc.frequency.exponentialRampToValueAtTime(800, now + 0.5);
                 osc.frequency.exponentialRampToValueAtTime(50, now + 1.5);
                 gain.gain.setValueAtTime(0.3, now);
                 gain.gain.linearRampToValueAtTime(0.01, now + 1.5);
                 osc.connect(gain);
                 gain.connect(audioCtx.destination);
                 osc.start();
                 osc.stop(now + 1.5);
            },
            
            buy: () => {
                if (isMuted || !audioCtx) return;
                const now = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.setValueAtTime(600, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 0.3);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(now + 0.3);
            }
        };
        
        // Mute Toggle
        document.getElementById('mute-btn').addEventListener('click', () => {
            isMuted = !isMuted;
            document.getElementById('mute-btn').innerText = isMuted ? "SOUND: OFF" : "SOUND: ON";
        });


        // --- Game Configuration & State ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let gameState = 'START'; 
        let score = 0;
        
        let highScore = localStorage.getItem('trek1942_highscore') || 0;
        document.getElementById('highscore-display').innerText = `High: ${highScore}`;

        let frameCount = 0;
        let difficultyMultiplier = 1;
        
        // Spawn Delay (for quiet time after boss)
        let spawnDelay = 0;
        
        // Screen Shake State
        let shakeDuration = 0;
        let shakeMagnitude = 0;
        
        // Ultimate Flash State
        let flashDuration = 0;

        // Boss State
        let bossActive = false;
        let currentBoss = null;
        let nextBossScore = 1000;
        let bossIndex = 0;
        // New non-infringing names
        const bossList = ["General Kael", "Void Lord", "Cyber Matriarch", "Cosmic Entity"];

        // Entity Arrays
        let player;
        let enemies = [];
        let bullets = [];
        let upgrades = [];
        let coins = []; // New Coin Array
        let particles = [];
        let stars = [];
        let planets = []; 
        let mines = [];
        let rockets = [];
        let floatingTexts = []; // New Array for Damage Numbers

        // Input State
        const input = {
            x: 0,
            y: 0,
            isTouching: false
        };
        
        // Relative Touch State
        let dragStartX = 0;
        let dragStartY = 0;
        let playerStartX = 0;
        let playerStartY = 0;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (player) {
                player.x = Math.min(Math.max(player.x, player.width/2), canvas.width - player.width/2);
                player.y = Math.min(Math.max(player.y, player.height/2), canvas.height - player.height/2);
                player.targetX = player.x;
                player.targetY = player.y;
            }
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Input Listeners ---
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState !== 'PLAYING') return;
            input.isTouching = true;
            dragStartX = e.touches[0].clientX;
            dragStartY = e.touches[0].clientY;
            playerStartX = player.targetX; 
            playerStartY = player.targetY;
        }, {passive: false});

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (gameState !== 'PLAYING') return;
            const currentX = e.touches[0].clientX;
            const currentY = e.touches[0].clientY;
            const dx = currentX - dragStartX;
            const dy = currentY - dragStartY;
            player.setTarget(playerStartX + dx, playerStartY + dy);
        }, {passive: false});

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            input.isTouching = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (gameState !== 'PLAYING') return;
            if (!input.isTouching) {
                player.setTarget(e.clientX, e.clientY);
            }
        });

        canvas.addEventListener('mousedown', () => input.isTouching = true);
        canvas.addEventListener('mouseup', () => input.isTouching = false);
        
        // --- Pause Logic ---
        const pauseBtn = document.getElementById('pause-btn');
        const resumeBtn = document.getElementById('resume-btn');
        const pauseScreen = document.getElementById('pause-screen');
        
        pauseBtn.addEventListener('click', () => {
            if (gameState === 'PLAYING') {
                gameState = 'PAUSED';
                pauseScreen.style.display = 'flex';
                if(audioCtx && audioCtx.state === 'running') audioCtx.suspend();
            }
        });
        
        resumeBtn.addEventListener('click', () => {
            if (gameState === 'PAUSED') {
                gameState = 'PLAYING';
                pauseScreen.style.display = 'none';
                if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
            }
        });
        
        // --- Upgrade UI Logic ---
        const upgradeBtnBottom = document.getElementById('upgrade-btn-bottom'); // Changed ID
        const upgradeScreen = document.getElementById('upgrade-screen');
        const closeUpgradeBtn = document.getElementById('close-upgrade-btn');
        
        upgradeBtnBottom.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent movement
            if (gameState === 'PLAYING') {
                gameState = 'PAUSED'; 
                upgradeScreen.style.display = 'flex';
                updateUpgradeUI();
                if(audioCtx && audioCtx.state === 'running') audioCtx.suspend();
            }
        });
        
        closeUpgradeBtn.addEventListener('click', () => {
            if (gameState === 'PAUSED') {
                gameState = 'PLAYING';
                upgradeScreen.style.display = 'none';
                if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
            }
        });
        
        // Global function for HTML buttons
        window.buyUpgrade = function(type, cost) {
            if(player.coins >= cost) {
                player.coins -= cost;
                SoundManager.buy();
                
                if(type === 'repair') {
                    player.hp = Math.min(player.maxHp, player.hp + 50);
                    updateHealth();
                }
                else if(type === 'maxhp') {
                    player.maxHp += 20;
                    player.hp += 20; // Heal the amount added
                    updateHealth();
                }
                else if(type === 'damage') {
                    player.damage += 1;
                }
                else if(type === 'firerate') {
                    player.fireRateModifier *= 0.9; // 10% faster firing
                }
                
                updateUpgradeUI();
                // Update main HUD - Changed Text
                document.getElementById('latinum-display').innerText = `Credits: ${player.coins}`;
            }
        }
        
        function updateUpgradeUI() {
            document.getElementById('current-latinum').innerText = `Credits: ${player.coins}`;
            // Enable/Disable buttons based on cost
            const btns = document.querySelectorAll('.upgrade-buy-btn');
            btns.forEach(btn => {
                // Parse cost from the onclick attribute string "buyUpgrade('type', COST)"
                const cost = parseInt(btn.getAttribute('onclick').split(',')[1]);
                btn.disabled = player.coins < cost;
            });
        }
        
        // --- Ultimate Trigger ---
        const ultBtn = document.getElementById('ultimate-btn');
        ultBtn.addEventListener('click', (e) => {
            e.stopPropagation(); 
            if(gameState === 'PLAYING' && player && player.ultimateCharge >= player.maxUltimate) {
                triggerUltimate();
            }
        });

        function triggerShake(frames, mag) {
            shakeDuration = frames;
            shakeMagnitude = mag;
        }

        function triggerUltimate() {
            player.ultimateCharge = 0;
            updateUltimateUI();
            SoundManager.ultimate();
            triggerShake(20, 10);
            flashDuration = 20; 
            
            bullets = bullets.filter(b => !b.isEnemy);
            
            enemies.forEach(e => {
                if(e.active) {
                    e.takeDamage(50); 
                    if(!e.active) {
                        score += e.scoreVal;
                        spawnCoins(e.x, e.y, e.type === 'cube' ? 5 : 2); // Drop some coins
                        for(let i=0; i<8; i++) particles.push(new Particle(e.x, e.y, '#fff'));
                    }
                }
            });
            
            if(bossActive && currentBoss && currentBoss.active) {
                currentBoss.takeDamage(50);
                for(let i=0; i<15; i++) particles.push(new Particle(currentBoss.x, currentBoss.y, '#fff'));
                if(!currentBoss.active) handleBossDefeat();
            }
        }

        function updateUltimateUI() {
            if(!player) return;
            const pct = Math.floor((player.ultimateCharge / player.maxUltimate) * 100);
            if (player.ultimateCharge >= player.maxUltimate) {
                ultBtn.innerText = "FIRE";
                ultBtn.classList.add('ready');
                ultBtn.style.background = ""; 
            } else {
                ultBtn.innerText = pct + "%";
                ultBtn.classList.remove('ready');
                ultBtn.style.background = `linear-gradient(to top, #444 ${pct}%, #222 ${pct}%)`;
            }
        }

        // --- Classes ---
        
        class FloatingText {
            constructor(x, y, text, color, size = 14) {
                this.x = x + (Math.random() * 20 - 10); // Slight random X offset
                this.y = y;
                this.text = text;
                this.color = color;
                this.size = size;
                this.life = 1.0; // Opacity/Life
                this.vy = 1.5; // Float speed
            }

            update() {
                this.y -= this.vy;
                this.life -= 0.02; // Fade out speed
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.font = `bold ${this.size}px Arial`;
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.strokeText(this.text, this.x, this.y);
                ctx.fillText(this.text, this.x, this.y);
                ctx.restore();
            }
        }
        
        class Coin {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 15;
                this.height = 15;
                this.vy = 3; // Moves down
                this.vx = (Math.random() - 0.5) * 2;
                this.active = true;
                this.frame = 0;
            }
            
            update() {
                this.y += this.vy;
                this.x += this.vx;
                this.frame++;
                
                // Magnetic effect if player upgraded? (Not implemented yet, sticking to manual pickup)
                // Basic homing if close
                const dist = Math.hypot(player.x - this.x, player.y - this.y);
                if(dist < 100) {
                    this.x += (player.x - this.x) * 0.1;
                    this.y += (player.y - this.y) * 0.1;
                }
                
                if (this.y > canvas.height + 20) this.active = false;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                // Gold Bar
                ctx.fillStyle = '#ffcc00';
                ctx.shadowBlur = 5;
                ctx.shadowColor = '#ffcc00';
                ctx.fillRect(-6, -4, 12, 8);
                ctx.strokeStyle = '#fff7cc';
                ctx.lineWidth = 1;
                ctx.strokeRect(-6, -4, 12, 8);
                ctx.restore();
            }
        }

        class Planet {
            constructor() {
                this.reset();
                this.y = Math.random() * canvas.height; 
            }

            reset() {
                this.radius = Math.random() * 40 + 20; 
                this.x = Math.random() * (canvas.width - this.radius*2) + this.radius;
                this.y = -this.radius * 2 - (Math.random() * 2000); 
                this.speed = Math.random() * 0.3 + 0.1; 
                
                const hues = [0, 200, 280, 30, 120]; 
                this.hue = hues[Math.floor(Math.random() * hues.length)];
                this.type = Math.random() > 0.5 ? 'gas' : 'terrestrial';
            }

            update() {
                this.y += this.speed * (gameState === 'PLAYING' ? 1 : 0.1);
                if (this.y > canvas.height + this.radius * 2) {
                     this.reset();
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                const grad = ctx.createRadialGradient(-this.radius*0.3, -this.radius*0.3, this.radius * 0.1, 0, 0, this.radius);
                grad.addColorStop(0, `hsla(${this.hue}, 80%, 70%, 0.3)`);
                grad.addColorStop(0.5, `hsla(${this.hue}, 60%, 50%, 0.3)`);
                grad.addColorStop(1, `hsla(${this.hue}, 60%, 20%, 0.3)`);
                
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI*2);
                ctx.fill();
                
                if (this.type === 'gas') {
                    ctx.strokeStyle = `hsla(${this.hue}, 40%, 80%, 0.1)`;
                    ctx.lineWidth = 6;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.radius * 1.6, this.radius * 0.3, Math.PI / 8, 0, Math.PI*2);
                    ctx.stroke();
                }
                
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.beginPath();
                ctx.arc(5, 5, this.radius, 0, Math.PI*2);
                ctx.fill();
                
                ctx.restore();
            }
        }

        class Star {
            constructor() {
                this.reset();
                this.y = Math.random() * canvas.height;
            }

            reset() {
                this.x = Math.random() * canvas.width;
                this.y = -10;
                
                const layer = Math.random();
                if (layer < 0.6) {
                    this.z = 0.5; 
                    this.size = Math.random() * 1 + 0.5;
                    this.opacity = Math.random() * 0.3 + 0.1;
                } else if (layer < 0.9) {
                    this.z = 1.5; 
                    this.size = Math.random() * 1.5 + 1;
                    this.opacity = Math.random() * 0.4 + 0.3;
                } else {
                    this.z = 3.5; 
                    this.size = Math.random() * 2 + 1.5;
                    this.opacity = Math.random() * 0.3 + 0.7;
                }
            }

            update() {
                this.y += this.z * (gameState === 'PLAYING' ? 3 : 0.5); 
                if (this.y > canvas.height) this.reset();
            }

            draw() {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.vx = (Math.random() - 0.5) * 6;
                this.vy = (Math.random() - 0.5) * 6;
                this.life = 1.0;
                this.decay = Math.random() * 0.03 + 0.02;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
            }

            draw() {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class Upgrade {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vy = 2;
                this.width = 30;
                this.height = 30;
                this.active = true;
                
                const r = Math.random();
                if (r < 0.2) this.type = 'SHIELD';
                else if (r < 0.4) this.type = 'WINGMAN';
                else if (r < 0.6) this.type = 'RAPID';
                else if (r < 0.8) this.type = 'ROCKET';
                else this.type = 'MINE';
            }

            update() {
                this.y += this.vy;
                if (this.y > canvas.height + 50) this.active = false;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.shadowBlur = 10;
                
                if (this.type === 'SHIELD') {
                    ctx.fillStyle = '#00aaff';
                    ctx.shadowColor = '#00aaff';
                    ctx.beginPath();
                    ctx.arc(0, 0, 15, 0, Math.PI*2);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('S', 0, 1);
                } 
                else if (this.type === 'WINGMAN') {
                    ctx.fillStyle = '#ffcc00';
                    ctx.shadowColor = '#ffcc00';
                    ctx.beginPath();
                    ctx.arc(0, 0, 15, 0, Math.PI*2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('W', 0, 1);
                } 
                else if (this.type === 'RAPID') {
                    ctx.fillStyle = '#ff3300';
                    ctx.shadowColor = '#ff3300';
                    ctx.beginPath();
                    ctx.arc(0, 0, 15, 0, Math.PI*2);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('F', 0, 1);
                }
                else if (this.type === 'ROCKET') {
                    ctx.fillStyle = '#ff9900';
                    ctx.shadowColor = '#ff9900';
                    ctx.beginPath();
                    ctx.arc(0, 0, 15, 0, Math.PI*2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('R', 0, 1);
                }
                else if (this.type === 'MINE') {
                    ctx.fillStyle = '#cc00cc';
                    ctx.shadowColor = '#cc00cc';
                    ctx.beginPath();
                    ctx.arc(0, 0, 15, 0, Math.PI*2);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('M', 0, 1);
                }
                ctx.restore();
            }
        }

        class Mine {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 20;
                this.height = 20;
                this.active = true;
                this.blink = 0;
            }

            update() {
                // Now moves UP (Forward) instead of down
                this.y -= 3; 
                this.blink++;
                // Despawn when it goes off the TOP of the screen
                if (this.y < -50) this.active = false;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.fillStyle = (Math.floor(this.blink / 10) % 2 === 0) ? '#cc00cc' : '#ff00ff';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#cc00cc';
                
                ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                    let angle = (i / 8) * Math.PI * 2;
                    ctx.lineTo(Math.cos(angle) * 10, Math.sin(angle) * 10);
                    ctx.lineTo(Math.cos(angle + 0.4) * 5, Math.sin(angle + 0.4) * 5);
                }
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
        }

        class Rocket {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 10;
                this.height = 20;
                this.active = true;
                this.target = null;
                this.speed = 8;
                this.angle = -Math.PI / 2; // Pointing up
            }

            update() {
                if (!this.target || !this.target.active) {
                    let closest = null;
                    let minDist = Infinity;
                    
                    if (bossActive && currentBoss) {
                        this.target = currentBoss;
                    } else {
                        enemies.forEach(e => {
                            if (!e.active) return;
                            const dist = Math.hypot(e.x - this.x, e.y - this.y);
                            if (dist < minDist) {
                                minDist = dist;
                                closest = e;
                            }
                        });
                        this.target = closest;
                    }
                }

                if (this.target) {
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const targetAngle = Math.atan2(dy, dx);
                    
                    let diff = targetAngle - this.angle;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    this.angle += diff * 0.1;
                }

                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                
                if (Math.random() < 0.5) {
                    particles.push(new Particle(this.x, this.y, '#ff9900'));
                }

                if (this.y < -50 || this.y > canvas.height + 50 || this.x < -50 || this.x > canvas.width + 50) {
                    this.active = false;
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle + Math.PI/2); 
                
                ctx.fillStyle = '#fff';
                ctx.fillRect(-3, -10, 6, 15); // Body
                ctx.fillStyle = '#ff9900';
                ctx.fillRect(-3, 5, 6, 5); // Thruster
                
                ctx.restore();
            }
        }

        class Bullet {
            constructor(x, y, isEnemy) {
                this.x = x;
                this.y = y;
                this.isEnemy = isEnemy;
                this.width = 4;
                this.height = 15;
                this.speed = isEnemy ? 7 : -12;
                this.active = true;
            }

            update() {
                this.y += this.speed;
                if (this.y < -50 || this.y > canvas.height + 50) {
                    this.active = false;
                }
            }

            draw() {
                ctx.save();
                if (this.isEnemy) {
                    ctx.fillStyle = '#00ff00';
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = '#00ff00';
                } else {
                    ctx.fillStyle = '#ffaa00';
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = '#ffaa00';
                }
                ctx.fillRect(this.x - this.width/2, this.y, this.width, this.height);
                ctx.restore();
            }
        }

        class Ship {
            constructor(x, y, hp) {
                this.x = x;
                this.y = y;
                this.hp = hp;
                this.maxHp = hp;
                this.width = 40;
                this.height = 40;
                this.active = true;
                this.flashTimer = 0;
            }

            takeDamage(amount) {
                this.hp -= amount;
                this.flashTimer = 5;
                
                // --- Floating Text Logic ---
                let color = '#fff';
                let size = 14;
                
                if (this.isPlayer) {
                    color = '#ff3333'; // Red for player damage
                    size = 16;
                } else if (amount > 5) {
                    color = '#ffcc00'; // Gold for heavy damage (Crits)
                    size = 20;
                }
                
                // Spawn text
                if (gameState === 'PLAYING') {
                    floatingTexts.push(new FloatingText(this.x, this.y - 20, "-" + Math.floor(amount), color, size));
                }
                
                if (this.hp <= 0) {
                    this.explode();
                    this.active = false;
                }
            }

            explode() {
                for(let i=0; i<15; i++) {
                    particles.push(new Particle(this.x, this.y, this.isPlayer ? '#00aaff' : '#ffaa00'));
                }
            }
        }

        class Player extends Ship {
            constructor() {
                super(canvas.width / 2, canvas.height - 100, 100);
                this.isPlayer = true;
                this.width = 60;
                this.height = 70;
                this.lastShot = 0;
                this.fireRate = 30; 
                
                // Upgrades Properties
                this.coins = 0;
                this.damage = 1; // Base damage
                this.fireRateModifier = 1.0; // Multiplier for fire rate
                
                this.wingmanTimer = 0;
                this.rapidTimer = 0;
                this.rocketTimer = 0;
                this.mineTimer = 0;
                this.maxTimer = 600;
                
                // Ultimate Logic
                this.ultimateCharge = 0;
                this.maxUltimate = 100;
            }

            setTarget(tx, ty) {
                this.targetX = tx;
                this.targetY = ty;
            }

            activateUpgrade(type) {
                if (type === 'SHIELD') {
                    this.hp = Math.min(this.maxHp, this.hp + 50);
                    updateHealth();
                } 
                else if (type === 'WINGMAN') {
                    this.wingmanTimer += this.maxTimer; 
                } 
                else if (type === 'RAPID') {
                    this.rapidTimer += this.maxTimer; 
                }
                else if (type === 'ROCKET') {
                    this.rocketTimer += this.maxTimer; 
                }
                else if (type === 'MINE') {
                    this.mineTimer += this.maxTimer; 
                }
                updateTimersUI();
            }

            update() {
                if (this.targetX !== undefined) {
                    this.x += (this.targetX - this.x) * 0.15;
                    this.y += (this.targetY - this.y) * 0.15;
                }

                this.x = Math.max(this.width/2, Math.min(canvas.width - this.width/2, this.x));
                this.y = Math.max(this.height/2, Math.min(canvas.height - this.height/2, this.y));

                // Ultimate Charge
                if (this.ultimateCharge < this.maxUltimate) {
                    this.ultimateCharge += 0.04; 
                    
                    if (this.ultimateCharge >= this.maxUltimate) {
                        this.ultimateCharge = this.maxUltimate;
                        updateUltimateUI(); 
                    } else if (frameCount % 30 === 0) {
                        updateUltimateUI();
                    }
                }

                // Progression
                const prog = Math.min(bossIndex, 5);
                // Apply Upgrade Modifier to Fire Rate
                const currentBaseRate = (30 - (prog * 3)) * this.fireRateModifier;
                const currentRapidRate = (16 - (prog * 1.6)) * this.fireRateModifier;

                if (this.rapidTimer > 0) {
                    this.rapidTimer--;
                    this.fireRate = currentRapidRate;
                } else {
                    this.fireRate = currentBaseRate;
                }
                
                if (this.wingmanTimer > 0) this.wingmanTimer--;
                if (this.rocketTimer > 0) this.rocketTimer--;
                if (this.mineTimer > 0) this.mineTimer--;

                if (frameCount - this.lastShot > this.fireRate) {
                    this.shoot();
                    this.lastShot = frameCount;
                }
                
                const rocketRate = 60 - (prog * 6);
                if (this.rocketTimer > 0 && frameCount % Math.floor(rocketRate) === 0) {
                    rockets.push(new Rocket(this.x, this.y));
                }
                
                const mineRate = 90 - (prog * 9);
                if (this.mineTimer > 0 && frameCount % Math.floor(mineRate) === 0) {
                    mines.push(new Mine(this.x, this.y - 30));
                }
                
                // --- Engine Trails (New Feature) ---
                // Add particles behind ship
                if (frameCount % 3 === 0) {
                    // Left Nacelle
                    particles.push(new Particle(this.x - 20, this.y + 30, '#00d4ff'));
                    // Right Nacelle
                    particles.push(new Particle(this.x + 20, this.y + 30, '#00d4ff'));
                }

                if (this.flashTimer > 0) this.flashTimer--;
                
                if (frameCount % 5 === 0) updateTimersUI();
            }

            shoot() {
                SoundManager.shoot(); 
                bullets.push(new Bullet(this.x - 15, this.y - 20, false));
                bullets.push(new Bullet(this.x + 15, this.y - 20, false));
                
                if (this.wingmanTimer > 0) {
                    bullets.push(new Bullet(this.x - 50, this.y, false));
                    bullets.push(new Bullet(this.x + 50, this.y, false));
                }
            }

            drawWingman(offsetX) {
                ctx.save();
                ctx.translate(offsetX, 10);
                ctx.scale(0.6, 0.6);
                ctx.fillStyle = '#ddd';
                ctx.beginPath();
                ctx.moveTo(0, -30);
                ctx.lineTo(15, 10);
                ctx.lineTo(10, 20);
                ctx.lineTo(-10, 20);
                ctx.lineTo(-15, 10);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = '#0099ff';
                ctx.fillRect(-12, 10, 4, 10);
                ctx.fillRect(8, 10, 4, 10);
                ctx.restore();
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                if (this.flashTimer > 0) ctx.globalCompositeOperation = 'source-atop'; 

                ctx.fillStyle = '#ddd';
                ctx.beginPath();
                ctx.ellipse(0, -15, 30, 15, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ccc';
                ctx.fillRect(-5, 0, 10, 35);
                ctx.fillStyle = '#eee';
                ctx.fillRect(-25, 10, 8, 30);
                ctx.fillRect(17, 10, 8, 30);
                ctx.fillStyle = '#0099ff';
                ctx.fillRect(-24, 35, 6, 4);
                ctx.fillRect(18, 35, 6, 4);
                ctx.fillStyle = '#ff3300';
                ctx.beginPath();
                ctx.arc(0, 5, 3, 0, Math.PI * 2);
                ctx.fill();

                if (this.flashTimer > 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.beginPath();
                    ctx.arc(0, 0, 40, 0, Math.PI*2);
                    ctx.fill();
                }
                
                if (this.wingmanTimer > 0) {
                    this.drawWingman(-50);
                    this.drawWingman(50);
                }

                ctx.restore();
            }
        }

        class Enemy extends Ship {
            constructor(type) {
                super(Math.random() * (canvas.width - 40) + 20, -50, 1);
                this.type = type; 
                
                this.vy = Math.random() * 1.5 + 1 + (difficultyMultiplier * 0.3);
                this.vx = Math.sin(this.y * 0.01) * 2; 
                this.swing = Math.random() * 0.05;
                
                if (type === 'cube') {
                    this.hp = 15 * difficultyMultiplier;
                    this.width = 80;
                    this.height = 80;
                    this.scoreVal = 150;
                    this.vy = 0.5 + (difficultyMultiplier * 0.1);
                } else if (type === 'cruiser') {
                    this.hp = 3 * difficultyMultiplier;
                    this.width = 72;
                    this.height = 48;
                    this.scoreVal = 50;
                } else {
                    this.hp = 1 * difficultyMultiplier;
                    this.width = 48;
                    this.height = 48;
                    this.scoreVal = 10;
                }
            }

            update() {
                this.y += this.vy;
                this.x += Math.sin(frameCount * this.swing) * 2;

                const prog = Math.min(bossIndex, 5);
                const baseChance = 0.0015 + (prog * 0.0003);

                if (Math.random() < baseChance * difficultyMultiplier) {
                    SoundManager.enemyShoot(); 
                    bullets.push(new Bullet(this.x, this.y + 20, true));
                }

                if (this.y > canvas.height + 50) this.active = false;
                if (this.flashTimer > 0) this.flashTimer--;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                if (this.type !== 'cube') {
                    ctx.scale(1.2, -1.2); 
                }

                if (this.flashTimer > 0) ctx.globalAlpha = 0.7;

                // --- HIGH FIDELITY ENEMY ART ---
                
                if (this.type === 'cube') {
                    // CYBER CUBE
                    const size = this.width / 1.5;
                    const depth = size * 0.4;
                    
                    // 1. Side Face (Darker)
                    ctx.fillStyle = '#0a0a0a';
                    ctx.beginPath();
                    ctx.moveTo(size/2, -size/2);
                    ctx.lineTo(size/2 + depth, -size/2 - depth);
                    ctx.lineTo(size/2 + depth, size/2 - depth);
                    ctx.lineTo(size/2, size/2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke(); 
                    
                    // 2. Top Face (Lighter)
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.moveTo(-size/2, -size/2);
                    ctx.lineTo(-size/2 + depth, -size/2 - depth);
                    ctx.lineTo(size/2 + depth, -size/2 - depth);
                    ctx.lineTo(size/2, -size/2);
                    ctx.closePath();
                    ctx.fill();

                    // 3. Front Face (Main)
                    ctx.fillStyle = '#111';
                    ctx.strokeStyle = '#003300'; 
                    ctx.lineWidth = 1;
                    ctx.fillRect(-size/2, -size/2, size, size);
                    ctx.strokeRect(-size/2, -size/2, size, size);

                    // 4. Complex Surface Texture (Procedural Piping)
                    ctx.strokeStyle = '#1f1'; // Bright green
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    // Draw circuit-like patterns
                    for(let i=0; i<6; i++) {
                        let y = -size/2 + (size/6)*i;
                        ctx.moveTo(-size/2, y);
                        ctx.lineTo(-size/2 + Math.random()*size, y);
                        let x = -size/2 + (size/6)*i;
                        ctx.moveTo(x, -size/2);
                        ctx.lineTo(x, -size/2 + Math.random()*size);
                    }
                    ctx.stroke();

                    // 5. Pulsing Green Light
                    let glow = 0.2 + 0.3 * Math.sin(frameCount * 0.1); 
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#0f0';
                    ctx.fillStyle = `rgba(50, 255, 50, ${glow})`;
                    
                    // Random lit windows
                    ctx.fillRect(-10, -10, 4, 4);
                    ctx.fillRect(15, 10, 3, 3);
                    ctx.fillRect(-20, 20, 5, 5);
                    
                    ctx.shadowBlur = 0; 
                } 
                else if (this.type === 'cruiser') {
                    // EMERALD WING (Cruiser)
                    
                    // Hull Gradient
                    let grad = ctx.createLinearGradient(-40, 0, 40, 0);
                    grad.addColorStop(0, '#1a3a2a'); 
                    grad.addColorStop(0.5, '#3a6e4e'); 
                    grad.addColorStop(1, '#1a3a2a');
                    ctx.fillStyle = grad;

                    // Upper Hull
                    ctx.beginPath();
                    ctx.moveTo(0, -5);
                    ctx.quadraticCurveTo(-35, -5, -45, 20); 
                    ctx.lineTo(-40, 30); 
                    ctx.bezierCurveTo(-20, 20, 20, 20, 40, 30); 
                    ctx.lineTo(45, 20); 
                    ctx.quadraticCurveTo(35, -5, 0, -5); 
                    ctx.fill();

                    // Lower Hull
                    ctx.beginPath();
                    ctx.moveTo(-40, 30);
                    ctx.bezierCurveTo(-30, 50, 30, 50, 40, 30); 
                    ctx.lineTo(35, 25); 
                    ctx.bezierCurveTo(10, 35, -10, 35, -35, 25); 
                    ctx.closePath();
                    ctx.fill();

                    // Head
                    ctx.fillStyle = '#1f2f2f';
                    ctx.beginPath();
                    ctx.ellipse(0, 2, 8, 12, 0, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Engine Glow
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#0f0';
                    ctx.fillStyle = '#aaffaa';
                    ctx.beginPath();
                    ctx.arc(0, 4, 2, 0, Math.PI*2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } 
                else {
                    // RAPTOR SCOUT
                    
                    // Engine Glow
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ff4400';
                    ctx.fillStyle = '#ff4400';
                    ctx.fillRect(-6, -8, 12, 6);
                    ctx.shadowBlur = 0;

                    // Main Hull
                    ctx.fillStyle = '#4a5a4a';
                    ctx.beginPath();
                    ctx.moveTo(0, 35); // Nose
                    ctx.lineTo(6, 10);
                    ctx.lineTo(6, -5);
                    ctx.lineTo(-6, -5);
                    ctx.lineTo(-6, 10);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Radiators
                    ctx.fillStyle = '#663333';
                    ctx.beginPath();
                    ctx.moveTo(0, 30);
                    ctx.lineTo(4, 15);
                    ctx.lineTo(-4, 15);
                    ctx.fill();

                    // Wings
                    let wingGrad = ctx.createLinearGradient(0, 0, 40, 0);
                    wingGrad.addColorStop(0, '#3e4e3e'); 
                    wingGrad.addColorStop(1, '#2a3a2a');
                    ctx.fillStyle = wingGrad;
                    
                    // Right Wing
                    ctx.beginPath();
                    ctx.moveTo(6, 5);
                    ctx.lineTo(45, 15); 
                    ctx.lineTo(40, -5); 
                    ctx.lineTo(10, -10); 
                    ctx.fill();
                    
                    // Left Wing
                    ctx.beginPath();
                    ctx.moveTo(-6, 5);
                    ctx.lineTo(-45, 15);
                    ctx.lineTo(-40, -5);
                    ctx.lineTo(-10, -10);
                    ctx.fill();

                    // Wing Guns
                    ctx.fillStyle = '#aa0000';
                    ctx.fillRect(-46, 14, 3, 8);
                    ctx.fillRect(43, 14, 3, 8);
                }
                ctx.restore();
            }
        }

        class Boss extends Ship {
            constructor(name) {
                super(canvas.width / 2, -100, 500);
                this.name = name;
                this.width = 120;
                this.height = 100;
                this.targetY = 100;
                this.phase = 0;
                this.isBoss = true;

                if (name === "General Kael") {
                    this.hp = 300;
                    this.maxHp = 300;
                    this.scoreVal = 1000;
                    this.color = '#aa3333';
                } else if (name === "Void Lord") {
                    this.hp = 500;
                    this.maxHp = 500;
                    this.scoreVal = 2000;
                    this.color = '#003300';
                } else if (name === "Cyber Matriarch") {
                    this.hp = 800;
                    this.maxHp = 800;
                    this.scoreVal = 3000;
                    this.color = '#333';
                    this.width = 150;
                    this.height = 150;
                } else {
                    this.hp = 1200;
                    this.maxHp = 1200;
                    this.scoreVal = 5000;
                    this.color = '#ffffff';
                }
            }

            update() {
                if (this.y < this.targetY) {
                    this.y += 1;
                } else {
                    this.x += Math.sin(frameCount * 0.02) * 3;
                    
                    if (this.name === "Cosmic Entity" && Math.random() < 0.01) {
                        this.x = Math.random() * (canvas.width - 100) + 50;
                    }
                }

                this.x = Math.max(this.width/2, Math.min(canvas.width - this.width/2, this.x));

                const prog = Math.min(bossIndex, 5);
                let chance = 0.025 + (prog * 0.005);

                if (Math.random() < chance) {
                     SoundManager.enemyShoot(); 
                     bullets.push(new Bullet(this.x, this.y + this.height/2, true));
                     if (this.name === "Void Lord" || this.name === "Cyber Matriarch") {
                         let b1 = new Bullet(this.x, this.y + this.height/2, true);
                         b1.speed = 6; b1.x -= 10;
                         let b2 = new Bullet(this.x, this.y + this.height/2, true);
                         b2.speed = 6; b2.x += 10;
                         bullets.push(b1, b2);
                     }
                }

                if (this.flashTimer > 0) this.flashTimer--;
                updateBossUI(this);
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                if (this.flashTimer > 0) ctx.globalAlpha = 0.7;

                // --- HIGH FIDELITY BOSS ART ---

                if (this.name === "General Kael") {
                    // Heavy Cruiser (The Retribution)
                    
                    // 1. Warp Nacelles (Lower layer)
                    let nacelleGrad = ctx.createLinearGradient(-55, 0, -45, 0);
                    nacelleGrad.addColorStop(0, '#556'); 
                    nacelleGrad.addColorStop(0.5, '#889'); 
                    nacelleGrad.addColorStop(1, '#556'); 
                    ctx.fillStyle = nacelleGrad;
                    
                    // Left
                    ctx.fillRect(-60, 10, 12, 60);
                    // Right
                    ctx.fillRect(48, 10, 12, 60);
                    
                    // Collectors (Red front)
                    ctx.fillStyle = '#cc0000';
                    ctx.fillRect(-60, 65, 12, 5);
                    ctx.fillRect(48, 65, 12, 5);
                    
                    // Warp Glow (Blue strip)
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#00f';
                    ctx.fillStyle = '#00ffff';
                    ctx.fillRect(-56, 15, 4, 45);
                    ctx.fillRect(52, 15, 4, 45);
                    ctx.shadowBlur = 0;

                    // 2. Main Saucer Section
                    let saucerGrad = ctx.createRadialGradient(0, 0, 10, 0, 0, 65);
                    saucerGrad.addColorStop(0, '#ccd'); 
                    saucerGrad.addColorStop(0.9, '#889'); 
                    saucerGrad.addColorStop(1, '#556'); 

                    ctx.fillStyle = saucerGrad;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 65, 65, 0, 0, Math.PI*2); // Full circle saucer
                    ctx.fill();
                    
                    // Bridge Dome
                    ctx.fillStyle = '#eee';
                    ctx.beginPath();
                    ctx.arc(0, 0, 10, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Hull Plating Lines
                    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(0, 0, 40, 0, Math.PI*2);
                    ctx.stroke();

                    // 3. Rollbar
                    ctx.fillStyle = '#667';
                    ctx.fillRect(-70, -25, 140, 15); 
                    
                    // Weapons Pod
                    ctx.fillStyle = '#778';
                    ctx.beginPath();
                    ctx.moveTo(-20, -25);
                    ctx.lineTo(-25, -45);
                    ctx.lineTo(25, -45);
                    ctx.lineTo(20, -25);
                    ctx.fill();
                    
                    // Laser glow
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(-15, -45, 6, 4);
                    ctx.fillRect(9, -45, 6, 4);
                } 
                else if (this.name === "Void Lord") {
                    // Mining Dreadnought (The Excavator)
                    
                    // Core
                    ctx.fillStyle = '#050505';
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#300';
                    ctx.beginPath();
                    ctx.arc(0, 0, 25, 0, Math.PI*2);
                    ctx.fill();
                    ctx.shadowBlur = 0;

                    // Tentacles/Drills
                    ctx.lineWidth = 4;
                    ctx.lineCap = 'round';
                    for(let i=0; i<8; i++) {
                        let angle = (i / 8) * Math.PI * 2 + frameCount * 0.01;
                        
                        // Gradient for arms
                        let armGrad = ctx.createLinearGradient(0,0, Math.cos(angle)*90, Math.sin(angle)*90);
                        armGrad.addColorStop(0, '#300');
                        armGrad.addColorStop(0.5, '#221'); 
                        armGrad.addColorStop(1, '#000');

                        ctx.strokeStyle = armGrad;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(angle)*20, Math.sin(angle)*20);
                        
                        // Wavy organic movement
                        let wave = Math.sin(frameCount * 0.1 + i) * 10;
                        let midX = Math.cos(angle) * 50 + Math.cos(angle + Math.PI/2) * wave;
                        let midY = Math.sin(angle) * 50 + Math.sin(angle + Math.PI/2) * wave;
                        
                        ctx.quadraticCurveTo(midX, midY, Math.cos(angle)*90, Math.sin(angle)*90);
                        ctx.stroke();
                        
                        // Drill tips (Glowing)
                        ctx.fillStyle = '#f00';
                        ctx.beginPath();
                        ctx.arc(Math.cos(angle)*90, Math.sin(angle)*90, 2, 0, Math.PI*2);
                        ctx.fill();
                    }
                } 
                else if (this.name === "Cyber Matriarch") {
                    // CYBER OCTA-CORE (Diamond)
                    
                    // Dark metallic fill
                    ctx.fillStyle = '#111';
                    
                    // Draw Diamond Shape
                    ctx.beginPath();
                    ctx.moveTo(0, -80); // Top
                    ctx.lineTo(60, 0);  // Right
                    ctx.lineTo(0, 80);  // Bottom
                    ctx.lineTo(-60, 0); // Left
                    ctx.closePath();
                    ctx.fill();
                    
                    // Internal Geometry (The 3D facets)
                    ctx.strokeStyle = '#383'; // Dull Green
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    // Cross
                    ctx.moveTo(0, -80); ctx.lineTo(0, 80);
                    ctx.moveTo(-60, 0); ctx.lineTo(60, 0);
                    // Inner Diamond
                    ctx.moveTo(0, -40); ctx.lineTo(30, 0); ctx.lineTo(0, 40); ctx.lineTo(-30, 0); ctx.lineTo(0, -40);
                    ctx.stroke();

                    // Pulsing Core
                    let pulse = 0.5 + 0.5 * Math.sin(frameCount * 0.05);
                    
                    ctx.shadowBlur = 20 * pulse;
                    ctx.shadowColor = '#0f0';
                    ctx.fillStyle = '#0f0';
                    
                    ctx.beginPath();
                    ctx.arc(0, 0, 10 + 5*pulse, 0, Math.PI*2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } 
                else if (this.name === "Cosmic Entity") {
                    // CHAOS ANOMALY
                    
                    // 1. Background Flash
                    let g = ctx.createRadialGradient(0, 0, 1, 0, 0, 70);
                    g.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    g.addColorStop(0.2, 'rgba(255, 0, 255, 0.8)'); 
                    g.addColorStop(0.6, 'rgba(100, 0, 255, 0.4)');
                    g.addColorStop(1, 'rgba(0,0,0,0)');
                    
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(0, 0, 70, 0, Math.PI*2);
                    ctx.fill();

                    // 2. Chaotic Arcs
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    
                    // Random spinning rings
                    for(let i=0; i<3; i++) {
                        ctx.strokeStyle = i%2==0 ? '#f0f' : '#0ff';
                        ctx.beginPath();
                        // Ellipse rotating over time
                        let rot = frameCount * (0.05 + i*0.02);
                        ctx.ellipse(0, 0, 60 - i*10, 20 + i*5, rot, 0, Math.PI*2);
                        ctx.stroke();
                    }
                    
                    // 3. Core Sparkle
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(0, 0, 15, 0, Math.PI*2);
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        // --- Game Logic Functions ---

        function spawnEnemies() {
            // No spawns if boss active OR during the 20s delay after boss
            if (bossActive || spawnDelay > 0) return; 

            if (Math.random() < 0.014 * difficultyMultiplier) {
                const rand = Math.random();
                let type;
                if (rand > 0.95) type = 'cube';    
                else if (rand > 0.7) type = 'cruiser'; 
                else type = 'scout';                  
                enemies.push(new Enemy(type));
            }
        }
        
        function spawnCoins(x, y, amount) {
            for(let i=0; i<amount; i++) {
                coins.push(new Coin(x, y));
            }
        }

        function checkBossSpawn() {
            // Only spawn boss if score reached AND we aren't in a delay period
            if (!bossActive && score >= nextBossScore && spawnDelay === 0) {
                bossActive = true;
                SoundManager.bossAlarm(); // SFX
                let name = bossList[bossIndex % bossList.length];
                currentBoss = new Boss(name);
                
                document.getElementById('boss-hud').style.display = 'flex';
                document.getElementById('boss-name').innerText = "WARNING: " + name;
                
                // Call Gemini API for Taunt
                getGeminiTaunt(name);
            }
        }
        
        function updateBossUI(boss) {
            const fill = document.getElementById('boss-health-fill');
            const pct = Math.max(0, (boss.hp / boss.maxHp) * 100);
            fill.style.width = pct + "%";
        }

        function spawnUpgrades() {
            if (Math.random() < 0.002) {
                upgrades.push(new Upgrade(Math.random() * (canvas.width - 60) + 30, -30));
            }
        }

        function checkCollisions() {
            // 1. Bullets
            bullets.forEach(b => {
                if (!b.active) return;
                
                if (!b.isEnemy) {
                    let hitBoss = false;
                    if (bossActive && currentBoss) {
                        if (Math.abs(b.x - currentBoss.x) < currentBoss.width/2 && Math.abs(b.y - currentBoss.y) < currentBoss.height/2) {
                            b.active = false;
                            hitBoss = true;
                            currentBoss.takeDamage(player.damage); // Use Player Damage
                            triggerShake(3, 2); 
                            if (!currentBoss.active) handleBossDefeat();
                        }
                    } 
                    
                    // Check enemies if boss wasn't hit (removed 'else' to allow killing lingering enemies during boss fights)
                    if (!hitBoss) {
                        enemies.forEach(e => {
                            if (!e.active || !b.active) return;
                            if (Math.abs(b.x - e.x) < e.width/2 && Math.abs(b.y - e.y) < e.height/2) {
                                b.active = false;
                                e.takeDamage(player.damage); // Use Player Damage
                                if (!e.active) {
                                    score += e.scoreVal;
                                    spawnCoins(e.x, e.y, e.type === 'cube' ? 5 : e.type === 'cruiser' ? 2 : 1);
                                    SoundManager.explode(); 
                                }
                            }
                        });
                    }
                } else {
                    // Enemy bullet hitting player
                    if (Math.abs(b.x - player.x) < player.width/2 - 10 && Math.abs(b.y - player.y) < player.height/2) {
                        b.active = false;
                        player.takeDamage(10);
                        triggerShake(15, 10); 
                        updateHealth();
                    }
                }
            });

            // 2. Rockets
            rockets.forEach(r => {
                if (!r.active) return;
                
                let hitBoss = false;
                if (bossActive && currentBoss) {
                     if (Math.hypot(r.x - currentBoss.x, r.y - currentBoss.y) < currentBoss.width/2) {
                        r.active = false;
                        hitBoss = true;
                        currentBoss.takeDamage(5 * player.damage); 
                        for(let i=0; i<5; i++) particles.push(new Particle(r.x, r.y, '#ff9900'));
                        triggerShake(8, 5); 
                        SoundManager.explode(); 
                        if (!currentBoss.active) handleBossDefeat();
                    }
                } 
                
                if (!hitBoss) {
                    enemies.forEach(e => {
                        if (!e.active || !r.active) return;
                        if (Math.hypot(r.x - e.x, r.y - e.y) < e.width/2 + 10) {
                            r.active = false;
                            e.takeDamage(10 * player.damage); 
                            for(let i=0; i<5; i++) particles.push(new Particle(r.x, r.y, '#ff9900'));
                            triggerShake(5, 3); 
                            if (!e.active) {
                                score += e.scoreVal;
                                spawnCoins(e.x, e.y, e.type === 'cube' ? 5 : 1);
                                SoundManager.explode(); 
                            }
                        }
                    });
                }
            });

            // 3. Mines
            mines.forEach(m => {
                if (!m.active) return;
                
                let hitBoss = false;
                if (bossActive && currentBoss) {
                     if (Math.abs(m.x - currentBoss.x) < currentBoss.width/2 && Math.abs(m.y - currentBoss.y) < currentBoss.height/2) {
                        m.active = false;
                        hitBoss = true;
                        currentBoss.takeDamage(20 * player.damage);
                        for(let i=0; i<10; i++) particles.push(new Particle(m.x, m.y, '#cc00cc'));
                        triggerShake(12, 8); 
                        SoundManager.explode(true); 
                        if (!currentBoss.active) handleBossDefeat();
                    }
                } 
                
                if (!hitBoss) {
                    enemies.forEach(e => {
                        if (!e.active || !m.active) return;
                        if (Math.abs(m.x - e.x) < e.width/2 + 10 && Math.abs(m.y - e.y) < e.height/2 + 10) {
                            m.active = false;
                            e.takeDamage(50 * player.damage); 
                            for(let i=0; i<10; i++) particles.push(new Particle(m.x, m.y, '#cc00cc'));
                            triggerShake(8, 5);
                            if (!e.active) {
                                score += e.scoreVal;
                                spawnCoins(e.x, e.y, 3);
                                SoundManager.explode(true); 
                            }
                        }
                    });
                }
            });

            document.getElementById('score-display').innerText = `Score: ${score}`;

            // Boss vs Player
            if (bossActive && currentBoss) {
                 if (Math.abs(currentBoss.x - player.x) < (player.width + currentBoss.width)/2.5 && Math.abs(currentBoss.y - player.y) < (player.height + currentBoss.height)/2.5) {
                     player.takeDamage(5); 
                     triggerShake(5, 5);
                     updateHealth();
                 }
            }

            // Enemies vs Player
            enemies.forEach(e => {
                if (!e.active) return;
                if (Math.abs(e.x - player.x) < (player.width + e.width)/3 && Math.abs(e.y - player.y) < (player.height + e.height)/3) {
                    e.takeDamage(100); 
                    player.takeDamage(20); 
                    triggerShake(15, 10); 
                    SoundManager.explode(true); 
                    updateHealth();
                }
            });
            
            // Upgrades
            upgrades.forEach(u => {
                if (!u.active) return;
                const dx = player.x - u.x;
                const dy = player.y - u.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < (player.width/2 + u.width/2)) {
                    u.active = false;
                    SoundManager.powerup(); 
                    player.activateUpgrade(u.type);
                }
            });
            
            // Coins
            coins.forEach(c => {
                if (!c.active) return;
                const dx = player.x - c.x;
                const dy = player.y - c.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < (player.width/2 + c.width/2)) {
                    c.active = false;
                    SoundManager.coin();
                    player.coins++;
                    document.getElementById('latinum-display').innerText = `Credits: ${player.coins}`;
                }
            });
        }
        
        function handleBossDefeat() {
            triggerShake(60, 20); // Massive victory shake
            SoundManager.explode(true); // Big SFX
            score += currentBoss.scoreVal;
            spawnCoins(currentBoss.x, currentBoss.y, 30); // Jackpot
            bossActive = false;
            currentBoss = null;
            bossIndex++;
            nextBossScore = score + 1000; 
            
            // Set spawn delay to 20 seconds (approx 1200 frames at 60fps)
            spawnDelay = 1200;
            
            document.getElementById('boss-hud').style.display = 'none';
            player.hp = Math.min(player.maxHp, player.hp + 50);
            updateHealth();
        }

        function updateHealth() {
            const pct = Math.max(0, Math.ceil((player.hp / player.maxHp) * 100));
            document.getElementById('health-display').innerText = `Shields: ${pct}%`;
            document.getElementById('health-display').style.color = pct < 30 ? '#ff3300' : '#00d4ff';
            
            if (player.hp <= 0) {
                endGame();
            }
        }
        
        function updateTimersUI() {
            const wingmanBar = document.getElementById('status-wingman');
            const rapidBar = document.getElementById('status-rapid');
            const rocketBar = document.getElementById('status-rocket');
            const mineBar = document.getElementById('status-mine');
            
            const updateBar = (bar, timer) => {
                if (timer > 0) {
                    bar.style.display = 'block';
                    bar.querySelector('.status-fill').style.width = (timer / player.maxTimer * 100) + '%';
                } else {
                    bar.style.display = 'none';
                }
            };
            
            updateBar(wingmanBar, player.wingmanTimer);
            updateBar(rapidBar, player.rapidTimer);
            updateBar(rocketBar, player.rocketTimer);
            updateBar(mineBar, player.mineTimer);
        }

        function initGame() {
            score = 0;
            frameCount = 0;
            difficultyMultiplier = 1;
            spawnDelay = 0; // Reset delay
            
            bossActive = false;
            bossIndex = 0;
            nextBossScore = 1000;
            currentBoss = null;
            document.getElementById('boss-hud').style.display = 'none';
            document.getElementById('new-highscore-msg').style.display = 'none';

            enemies = [];
            bullets = [];
            particles = [];
            upgrades = [];
            coins = [];
            rockets = [];
            mines = [];
            planets = []; 
            floatingTexts = []; // Reset text
            
            player = new Player();
            player.x = canvas.width / 2;
            player.y = canvas.height - 100;
            player.targetX = player.x;
            player.targetY = player.y;
            
            updateUltimateUI();
            document.getElementById('score-display').innerText = `Score: 0`;
            document.getElementById('latinum-display').innerText = `Credits: 0`;
            updateHealth();
            updateTimersUI();
            
            stars = [];
            for(let i=0; i<150; i++) stars.push(new Star());
            for(let i=0; i<3; i++) planets.push(new Planet());
        }

        function endGame() {
            gameState = 'GAMEOVER';
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('trek1942_highscore', highScore);
                document.getElementById('highscore-display').innerText = `High: ${highScore}`;
                document.getElementById('new-highscore-msg').style.display = 'block';
            }
            
            document.getElementById('final-score').innerText = `Final Score: ${score}`;
            document.getElementById('best-score').innerText = `High Score: ${highScore}`;
            document.getElementById('game-over-screen').classList.remove('hidden');
            document.getElementById('ui-layer').classList.add('hidden');
            document.getElementById('boss-hud').style.display = 'none';
            document.getElementById('ultimate-container').classList.add('hidden');
        }

        function gameLoop() {
            requestAnimationFrame(gameLoop);

            ctx.save();
            if (shakeDuration > 0) {
                const dx = (Math.random() - 0.5) * shakeMagnitude;
                const dy = (Math.random() - 0.5) * shakeMagnitude;
                ctx.translate(dx, dy);
                shakeDuration--;
            }

            if (flashDuration > 0) {
                ctx.fillStyle = '#fff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                flashDuration--;
                ctx.restore();
                return;
            }

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            planets.forEach(p => {
                p.update();
                p.draw();
            });
            
            stars.forEach(s => {
                s.update();
                s.draw();
            });

            if (gameState === 'PLAYING') {
                frameCount++;
                
                // Decrease spawn delay timer if active
                if (spawnDelay > 0) spawnDelay--;
                
                if (frameCount % 1200 === 0) difficultyMultiplier += 0.05;

                player.update();
                player.draw();

                checkBossSpawn();
                spawnEnemies();
                spawnUpgrades();

                if (bossActive && currentBoss) {
                    currentBoss.update();
                    currentBoss.draw();
                }

                enemies.forEach(e => e.update());
                enemies.forEach(e => e.draw());
                enemies = enemies.filter(e => e.active);

                upgrades.forEach(u => u.update());
                upgrades.forEach(u => u.draw());
                upgrades = upgrades.filter(u => u.active);
                
                coins.forEach(c => c.update());
                coins.forEach(c => c.draw());
                coins = coins.filter(c => c.active);

                bullets.forEach(b => b.update());
                bullets.forEach(b => b.draw());
                bullets = bullets.filter(b => b.active);
                
                rockets.forEach(r => r.update());
                rockets.forEach(r => r.draw());
                rockets = rockets.filter(r => r.active);

                mines.forEach(m => m.update());
                mines.forEach(m => m.draw());
                mines = mines.filter(m => m.active);

                particles.forEach(p => p.update());
                particles.forEach(p => p.draw());
                particles = particles.filter(p => p.life > 0);
                
                // Update & Draw Floating Text
                floatingTexts.forEach(t => {
                    t.update();
                    t.draw();
                });
                floatingTexts = floatingTexts.filter(t => t.life > 0);

                checkCollisions();
            }
            
            ctx.restore();
        }

        document.getElementById('start-btn').addEventListener('click', () => {
            SoundManager.init(); 
            initGame();
            gameState = 'PLAYING';
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('ui-layer').classList.remove('hidden');
            document.getElementById('ultimate-container').classList.remove('hidden');
        });

        document.getElementById('restart-btn').addEventListener('click', () => {
            SoundManager.init(); 
            initGame();
            gameState = 'PLAYING';
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('ui-layer').classList.remove('hidden');
            document.getElementById('ultimate-container').classList.remove('hidden');
        });

        for(let i=0; i<150; i++) stars.push(new Star());
        for(let i=0; i<3; i++) planets.push(new Planet());
        gameLoop();

    </script>
</body>
</html>